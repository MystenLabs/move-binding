---
source: move-binding/tests/snapshot_tests.rs
expression: pretty
---
pub mod sui {
    pub const PACKAGE_VERSION: u64 = 35u64;
    pub mod address {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "address";
        pub fn from_ascii_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_ascii_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_u256(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn hex_char_value(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hex_char_value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<move_types::U256> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn to_ascii_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_ascii_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_u256(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod authenticator_state {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "authenticator_state";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ActiveJwk {
            pub jwk_id: crate::sui::authenticator_state::JwkId,
            pub jwk: crate::sui::authenticator_state::JWK,
            pub epoch: u64,
        }
        impl ActiveJwk {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct AuthenticatorState {
            pub id: ObjectId,
            pub version: u64,
        }
        impl AuthenticatorState {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct AuthenticatorStateInner {
            pub version: u64,
            pub active_jwks: Vec<crate::sui::authenticator_state::ActiveJwk>,
        }
        impl AuthenticatorStateInner {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct JWK {
            pub kty: String,
            pub e: String,
            pub n: String,
            pub alg: String,
        }
        impl JWK {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct JwkId {
            pub iss: String,
            pub kid: String,
        }
        impl JwkId {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn active_jwk_equal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::ActiveJwk>,
            p1: Ref<'a, crate::sui::authenticator_state::ActiveJwk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("active_jwk_equal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn check_sorted<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<crate::sui::authenticator_state::ActiveJwk>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_sorted").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn create<'a>(builder: &mut sui_transaction_builder::TransactionBuilder) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
        pub fn deduplicate(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<crate::sui::authenticator_state::ActiveJwk>>,
        ) -> Arg<Vec<crate::sui::authenticator_state::ActiveJwk>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deduplicate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn expire_jwks<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::authenticator_state::AuthenticatorState>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("expire_jwks").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn get_active_jwks<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::AuthenticatorState>,
        ) -> Arg<Vec<crate::sui::authenticator_state::ActiveJwk>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_active_jwks").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn jwk_equal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::JWK>,
            p1: Ref<'a, crate::sui::authenticator_state::JWK>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("jwk_equal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn jwk_id_equal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::JwkId>,
            p1: Ref<'a, crate::sui::authenticator_state::JwkId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("jwk_id_equal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn jwk_lt<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::ActiveJwk>,
            p1: Ref<'a, crate::sui::authenticator_state::ActiveJwk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("jwk_lt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn load_inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::authenticator_state::AuthenticatorState>,
        ) -> Ref<'a, crate::sui::authenticator_state::AuthenticatorStateInner> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn load_inner_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::authenticator_state::AuthenticatorState>,
        ) -> MutRef<'a, crate::sui::authenticator_state::AuthenticatorStateInner> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_inner_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn string_bytes_lt<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("string_bytes_lt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn update_authenticator_state<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::authenticator_state::AuthenticatorState>,
            p1: Arg<Vec<crate::sui::authenticator_state::ActiveJwk>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_authenticator_state").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod bag {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "bag";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Bag {
            pub id: ObjectId,
            pub size: u64,
        }
        impl Bag {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains_with_type<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains_with_type").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::bag::Bag>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::bag::Bag>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::bag::Bag>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::bag::Bag> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bag::Bag>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod balance {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "balance";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Balance<T0> {
            pub value: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Balance<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Supply<T0> {
            pub value: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Supply<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn create_staking_rewards<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_staking_rewards").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn create_supply<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::sui::balance::Supply<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn decrease_supply<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Supply<T0>>,
            p1: Arg<crate::sui::balance::Balance<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("decrease_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_storage_rebates<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::balance::Balance<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_storage_rebates").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn destroy_supply<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::balance::Supply<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy_zero<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::balance::Balance<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn increase_supply<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Supply<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("increase_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn join<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Balance<T0>>,
            p1: Arg<crate::sui::balance::Balance<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn split<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Balance<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn supply_value<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::balance::Supply<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("supply_value").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn value<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::balance::Balance<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn withdraw_all<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Balance<T0>>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw_all").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn zero<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
    }
    pub mod bcs {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "bcs";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BCS {
            pub bytes: Vec<u8>,
        }
        impl BCS {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn into_remainder_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_remainder_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::bcs::BCS> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_bool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_bool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_enum_tag<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_enum_tag").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<Address>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_bool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<bool>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_bool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u128<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<u128>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u16<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<move_types::U256>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u32<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u64<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_option_u8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_option_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u128<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u16<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u32<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u64<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_u8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<Address>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_bool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<bool>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_bool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u128<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u128>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u16<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<move_types::U256>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u32<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u64<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_u8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_vec_vec_u8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<Vec<Vec<u8>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_vec_vec_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_bytes<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_bytes").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod bls12381 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "bls12381";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct G1 {
            pub dummy_field: bool,
        }
        impl G1 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct G2 {
            pub dummy_field: bool,
        }
        impl G2 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct GT {
            pub dummy_field: bool,
        }
        impl GT {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Scalar {
            pub dummy_field: bool,
        }
        impl Scalar {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UncompressedG1 {
            pub dummy_field: bool,
        }
        impl UncompressedG1 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn bls12381_min_pk_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bls12381_min_pk_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn bls12381_min_sig_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bls12381_min_sig_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn g1_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g1_div<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g1_from_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn g1_generator(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_generator").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn g1_identity(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_identity").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn g1_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g1_multi_scalar_multiplication<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<
                'a,
                Vec<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            >,
            p1: Ref<'a, Vec<crate::sui::group_ops::Element<crate::sui::bls12381::G1>>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_multi_scalar_multiplication").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g1_neg<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_neg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn g1_sub<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g1_to_uncompressed_g1<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g1_to_uncompressed_g1").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn g2_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g2_div<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g2_from_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn g2_generator(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_generator").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn g2_identity(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_identity").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn g2_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g2_multi_scalar_multiplication<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<
                'a,
                Vec<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            >,
            p1: Ref<'a, Vec<crate::sui::group_ops::Element<crate::sui::bls12381::G2>>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_multi_scalar_multiplication").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn g2_neg<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_neg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn g2_sub<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("g2_sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt_div<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt_generator(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_generator").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn gt_identity(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_identity").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn gt_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt_neg<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_neg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn gt_sub<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::GT>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt_sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn hash_to_g1<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_to_g1").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn hash_to_g2<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G2>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_to_g2").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pairing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G1>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::G2>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::GT>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pairing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn scalar_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn scalar_div<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn scalar_from_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn scalar_from_u64(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_from_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn scalar_inv<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_inv").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn scalar_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn scalar_neg<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_neg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn scalar_one(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_one").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn scalar_sub<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
            p1: Ref<'a, crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>>,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn scalar_zero(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::Scalar>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("scalar_zero").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn uncompressed_g1_sum<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<
                'a,
                Vec<crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>>,
            >,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uncompressed_g1_sum").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uncompressed_g1_to_g1<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<
                'a,
                crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
            >,
        ) -> Arg<crate::sui::group_ops::Element<crate::sui::bls12381::G1>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uncompressed_g1_to_g1").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod borrow {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "borrow";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Borrow {
            pub ref_: Address,
            pub obj: ObjectId,
        }
        impl Borrow {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Referent<T0> {
            pub id: Address,
            pub value: Option<T0>,
        }
        impl<T0> Referent<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn borrow<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::borrow::Referent<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::borrow::Referent<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::sui::borrow::Referent<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn put_back<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::borrow::Referent<T0>>,
            p1: Arg<T0>,
            p2: Arg<crate::sui::borrow::Borrow>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("put_back").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
    }
    pub mod clock {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "clock";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Clock {
            pub id: ObjectId,
            pub timestamp_ms: u64,
        }
        impl Clock {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn consensus_commit_prologue<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::clock::Clock>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("consensus_commit_prologue").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn create<'a>(builder: &mut sui_transaction_builder::TransactionBuilder) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
        pub fn timestamp_ms<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::clock::Clock>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("timestamp_ms").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod coin {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "coin";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Coin<T0> {
            pub id: ObjectId,
            pub balance: crate::sui::balance::Balance<T0>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Coin<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct CoinMetadata<T0> {
            pub id: ObjectId,
            pub decimals: u8,
            pub name: String,
            pub symbol: String,
            pub description: String,
            pub icon_url: Option<crate::sui::url::Url>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> CoinMetadata<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct CurrencyCreated<T0> {
            pub decimals: u8,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> CurrencyCreated<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct DenyCap<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> DenyCap<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct DenyCapV2<T0> {
            pub id: ObjectId,
            pub allow_global_pause: bool,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> DenyCapV2<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct RegulatedCoinMetadata<T0> {
            pub id: ObjectId,
            pub coin_metadata_object: ObjectId,
            pub deny_cap_object: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> RegulatedCoinMetadata<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct TreasuryCap<T0> {
            pub id: ObjectId,
            pub total_supply: crate::sui::balance::Supply<T0>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TreasuryCap<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn balance<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::Coin<T0>>,
        ) -> Ref<'a, crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("balance").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn balance_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
        ) -> MutRef<'a, crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("balance_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn burn<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<crate::sui::coin::Coin<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("burn").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn create_currency<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<u8>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Option<crate::sui::url::Url>>,
        ) -> Arg<crate::sui::coin::TreasuryCap<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_currency").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                )
                .into()
        }
        pub fn create_regulated_currency<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<u8>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Option<crate::sui::url::Url>>,
        ) -> Arg<crate::sui::coin::TreasuryCap<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_regulated_currency").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                )
                .into()
        }
        pub fn create_regulated_currency_v2<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<u8>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Option<crate::sui::url::Url>>,
            p6: Arg<bool>,
        ) -> Arg<crate::sui::coin::TreasuryCap<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_regulated_currency_v2").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into()
                    ],
                )
                .into()
        }
        pub fn deny_list_add<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCap<T0>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_add").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn deny_list_contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn deny_list_remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCap<T0>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn deny_list_v2_add<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCapV2<T0>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_add").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn deny_list_v2_contains_current_epoch<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_contains_current_epoch")
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn deny_list_v2_contains_next_epoch<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_contains_next_epoch")
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn deny_list_v2_disable_global_pause<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCapV2<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_disable_global_pause")
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn deny_list_v2_enable_global_pause<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCapV2<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_enable_global_pause")
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn deny_list_v2_is_global_pause_enabled_current_epoch<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str(
                                "deny_list_v2_is_global_pause_enabled_current_epoch",
                            )
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn deny_list_v2_is_global_pause_enabled_next_epoch<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str(
                                "deny_list_v2_is_global_pause_enabled_next_epoch",
                            )
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn deny_list_v2_remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: MutRef<'a, crate::sui::coin::DenyCapV2<T0>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_v2_remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn destroy_zero<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::Coin<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn divide_into_n<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<u64>,
        ) -> Arg<Vec<crate::sui::coin::Coin<T0>>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_into_n").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_balance<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::balance::Balance<T0>>,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_balance").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_decimals<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::CoinMetadata<T0>>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_decimals").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_description<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::CoinMetadata<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_description").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_icon_url<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::CoinMetadata<T0>>,
        ) -> Arg<Option<crate::sui::url::Url>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_icon_url").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_name<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::CoinMetadata<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_name").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_symbol<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::CoinMetadata<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_symbol").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn into_balance<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::Coin<T0>>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_balance").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn join<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<crate::sui::coin::Coin<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn migrate_regulated_currency_to_v2<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<crate::sui::coin::DenyCap<T0>>,
            p2: Arg<bool>,
        ) -> Arg<crate::sui::coin::DenyCapV2<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("migrate_regulated_currency_to_v2")
                            .unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn mint<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mint").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn mint_and_transfer<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<u64>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mint_and_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn mint_balance<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::balance::Balance<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mint_balance").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn put<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Balance<T0>>,
            p1: Arg<crate::sui::coin::Coin<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("put").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn split<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn supply<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> Ref<'a, crate::sui::balance::Supply<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn supply_immut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> Ref<'a, crate::sui::balance::Supply<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("supply_immut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn supply_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> MutRef<'a, crate::sui::balance::Supply<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("supply_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn take<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::balance::Balance<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("take").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn total_supply<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("total_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn treasury_into_supply<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::TreasuryCap<T0>>,
        ) -> Arg<crate::sui::balance::Supply<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("treasury_into_supply").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn update_description<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: MutRef<'a, crate::sui::coin::CoinMetadata<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_description").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn update_icon_url<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: MutRef<'a, crate::sui::coin::CoinMetadata<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_icon_url").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn update_name<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: MutRef<'a, crate::sui::coin::CoinMetadata<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_name").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn update_symbol<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: MutRef<'a, crate::sui::coin::CoinMetadata<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_symbol").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn value<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::Coin<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn zero<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
    }
    pub mod config {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "config";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Config<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Config<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Setting<T0> {
            pub data: Option<crate::sui::config::SettingData<T0>>,
        }
        impl<T0> Setting<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct SettingData<T0> {
            pub newer_value_epoch: u64,
            pub newer_value: Option<T0>,
            pub older_value_opt: Option<T0>,
        }
        impl<T0> SettingData<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add_for_next_epoch<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::config::Config<T0>>,
            p1: MutRef<'a, T0>,
            p2: Arg<T1>,
            p3: Arg<T2>,
        ) -> Arg<Option<T2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_for_next_epoch").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn borrow_for_next_epoch_mut<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::config::Config<T0>>,
            p1: MutRef<'a, T0>,
            p2: Arg<T1>,
        ) -> MutRef<'a, T2> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_for_next_epoch_mut").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn exists_with_type<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::config::Config<T0>>,
            p1: Arg<T1>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_with_type").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn exists_with_type_for_next_epoch<
            'a,
            T0: MoveType,
            T1: MoveType,
            T2: MoveType,
        >(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::config::Config<T0>>,
            p1: Arg<T1>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_with_type_for_next_epoch").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, T0>,
        ) -> Arg<crate::sui::config::Config<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn read_setting<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<Option<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("read_setting").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn read_setting_for_next_epoch<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::config::Config<T0>>,
            p1: Arg<T1>,
        ) -> Arg<Option<T2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("read_setting_for_next_epoch").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn read_setting_impl<
            T0: move_types::Key,
            T1: MoveType,
            T2: MoveType,
            T3: MoveType,
        >(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<Address>,
            p2: Arg<u64>,
        ) -> Arg<Option<T3>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("read_setting_impl").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_(), T3::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn remove_for_next_epoch<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::config::Config<T0>>,
            p1: MutRef<'a, T0>,
            p2: Arg<T1>,
        ) -> Arg<Option<T2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_for_next_epoch").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn share<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::config::Config<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("share").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn transfer<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::config::Config<T0>>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod deny_list {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "deny_list";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct AddressKey {
            pub pos0: Address,
        }
        impl AddressKey {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ConfigKey {
            pub per_type_index: u64,
            pub per_type_key: Vec<u8>,
        }
        impl ConfigKey {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ConfigWriteCap {
            pub dummy_field: bool,
        }
        impl ConfigWriteCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct DenyList {
            pub id: ObjectId,
            pub lists: crate::sui::bag::Bag,
        }
        impl DenyList {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct GlobalPauseKey {
            pub dummy_field: bool,
        }
        impl GlobalPauseKey {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PerTypeConfigCreated {
            pub key: crate::sui::deny_list::ConfigKey,
            pub config_id: ObjectId,
        }
        impl PerTypeConfigCreated {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct PerTypeList {
            pub id: ObjectId,
            pub denied_count: crate::sui::table::Table<Address, u64>,
            pub denied_addresses: crate::sui::table::Table<
                Vec<u8>,
                crate::sui::vec_set::VecSet<Address>,
            >,
        }
        impl PerTypeList {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add_per_type_config<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_per_type_config").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow_per_type_config<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) -> Ref<'a, crate::sui::config::Config<crate::sui::deny_list::ConfigWriteCap>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_per_type_config").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn borrow_per_type_config_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) -> MutRef<
            'a,
            crate::sui::config::Config<crate::sui::deny_list::ConfigWriteCap>,
        > {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_per_type_config_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn create<'a>(builder: &mut sui_transaction_builder::TransactionBuilder) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
        pub fn migrate_v1_to_v2<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("migrate_v1_to_v2").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn per_type_exists<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("per_type_exists").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn per_type_list<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::deny_list::PerTypeList> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("per_type_list").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn v1_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn v1_contains<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_contains").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn v1_per_type_list_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::PerTypeList>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_per_type_list_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn v1_per_type_list_contains<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::PerTypeList>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_per_type_list_contains").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn v1_per_type_list_remove<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::PerTypeList>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_per_type_list_remove").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn v1_remove<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v1_remove").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn v2_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn v2_contains_current_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_contains_current_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn v2_contains_next_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_contains_next_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn v2_disable_global_pause<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_disable_global_pause").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn v2_enable_global_pause<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_enable_global_pause").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn v2_is_global_pause_enabled_current_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_is_global_pause_enabled_current_epoch")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn v2_is_global_pause_enabled_next_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_is_global_pause_enabled_next_epoch")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn v2_remove<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::deny_list::DenyList>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("v2_remove").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
    }
    pub mod display {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "display";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Display<T0> {
            pub id: ObjectId,
            pub fields: crate::sui::vec_map::VecMap<String, String>,
            pub version: u16,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Display<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct DisplayCreated<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> DisplayCreated<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct VersionUpdated<T0> {
            pub id: ObjectId,
            pub version: u16,
            pub fields: crate::sui::vec_map::VecMap<String, String>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> VersionUpdated<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn add_internal<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_internal").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn add_multiple<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
            p1: Arg<Vec<String>>,
            p2: Arg<Vec<String>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_multiple").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn create_and_keep<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_and_keep").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn create_internal<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::display::Display<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_internal").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn edit<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("edit").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn fields<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::display::Display<T0>>,
        ) -> Ref<'a, crate::sui::vec_map::VecMap<String, String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fields").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_authorized<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_authorized").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<crate::sui::display::Display<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_with_fields<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
            p1: Arg<Vec<String>>,
            p2: Arg<Vec<String>>,
        ) -> Arg<crate::sui::display::Display<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_with_fields").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn remove<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn update_version<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::display::Display<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_version").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn version<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::display::Display<T0>>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("version").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod dynamic_field {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "dynamic_field";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Field<T0, T1> {
            pub id: ObjectId,
            pub name: T0,
            pub value: T1,
        }
        impl<T0, T1> Field<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn add_child_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_child_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_child_object<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<Address>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_child_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_child_object_mut<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<Address>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_child_object_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn exists_<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn exists_with_type<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_with_type").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn field_info<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("field_info").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn field_info_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> MutRef<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("field_info_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_child_object(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_child_object").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_child_object_with_ty<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<Address>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_child_object_with_ty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn hash_type_and_key<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<T0>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_type_and_key").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_child_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<Address>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_child_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_if_exists<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<Option<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_if_exists").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod dynamic_object_field {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "dynamic_object_field";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Wrapper<T0> {
            pub name: T0,
        }
        impl<T0> Wrapper<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn exists_<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn exists_with_type<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exists_with_type").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn id<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<Option<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_add<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn internal_borrow<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_borrow_mut<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_exists_with_type<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_exists_with_type").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_remove<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod ecdsa_k1 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "ecdsa_k1";
        pub fn decompress_pubkey<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("decompress_pubkey").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn secp256k1_ecrecover<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Arg<u8>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("secp256k1_ecrecover").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn secp256k1_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Arg<u8>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("secp256k1_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
    }
    pub mod ecdsa_r1 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "ecdsa_r1";
        pub fn secp256r1_ecrecover<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Arg<u8>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("secp256r1_ecrecover").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn secp256r1_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Arg<u8>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("secp256r1_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
    }
    pub mod ecvrf {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "ecvrf";
        pub fn ecvrf_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ecvrf_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
    }
    pub mod ed25519 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "ed25519";
        pub fn ed25519_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ed25519_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
    pub mod event {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "event";
        pub fn emit<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
    }
    pub mod groth16 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "groth16";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Curve {
            pub id: u8,
        }
        impl Curve {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PreparedVerifyingKey {
            pub vk_gamma_abc_g1_bytes: Vec<u8>,
            pub alpha_g1_beta_g2_bytes: Vec<u8>,
            pub gamma_g2_neg_pc_bytes: Vec<u8>,
            pub delta_g2_neg_pc_bytes: Vec<u8>,
        }
        impl PreparedVerifyingKey {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ProofPoints {
            pub bytes: Vec<u8>,
        }
        impl ProofPoints {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PublicProofInputs {
            pub bytes: Vec<u8>,
        }
        impl PublicProofInputs {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn bls12381(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::groth16::Curve> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bls12381").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn bn254(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::groth16::Curve> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bn254").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn prepare_verifying_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::groth16::Curve>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::groth16::PreparedVerifyingKey> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("prepare_verifying_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn prepare_verifying_key_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::groth16::PreparedVerifyingKey> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("prepare_verifying_key_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn proof_points_from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::groth16::ProofPoints> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("proof_points_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn public_proof_inputs_from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::groth16::PublicProofInputs> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_proof_inputs_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pvk_from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::groth16::PreparedVerifyingKey> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pvk_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn pvk_to_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::groth16::PreparedVerifyingKey>,
        ) -> Arg<Vec<Vec<u8>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pvk_to_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn verify_groth16_proof<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::groth16::Curve>,
            p1: Ref<'a, crate::sui::groth16::PreparedVerifyingKey>,
            p2: Ref<'a, crate::sui::groth16::PublicProofInputs>,
            p3: Ref<'a, crate::sui::groth16::ProofPoints>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_groth16_proof").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn verify_groth16_proof_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Ref<'a, Vec<u8>>,
            p4: Ref<'a, Vec<u8>>,
            p5: Ref<'a, Vec<u8>>,
            p6: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_groth16_proof_internal").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into()
                    ],
                )
                .into()
        }
    }
    pub mod group_ops {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "group_ops";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Element<T0> {
            pub bytes: Vec<u8>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Element<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p2: Ref<'a, crate::sui::group_ops::Element<T0>>,
        ) -> Arg<crate::sui::group_ops::Element<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn bytes<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<T0>>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bytes").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn convert<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
            p2: Ref<'a, crate::sui::group_ops::Element<T0>>,
        ) -> Arg<crate::sui::group_ops::Element<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("convert").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn div<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p2: Ref<'a, crate::sui::group_ops::Element<T1>>,
        ) -> Arg<crate::sui::group_ops::Element<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("div").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn equal<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("equal").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_bytes<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Arg<bool>,
        ) -> Arg<crate::sui::group_ops::Element<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_bytes").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn hash_to<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<crate::sui::group_ops::Element<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_to").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_convert<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_convert").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_div<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_hash_to<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_hash_to").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_multi_scalar_mul<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_multi_scalar_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_pairing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_pairing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_sub<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn internal_sum<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<Vec<u8>>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_sum").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_validate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_validate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn mul<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p2: Ref<'a, crate::sui::group_ops::Element<T1>>,
        ) -> Arg<crate::sui::group_ops::Element<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mul").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn multi_scalar_multiplication<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<crate::sui::group_ops::Element<T0>>>,
            p2: Ref<'a, Vec<crate::sui::group_ops::Element<T1>>>,
        ) -> Arg<crate::sui::group_ops::Element<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("multi_scalar_multiplication").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn pairing<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p2: Ref<'a, crate::sui::group_ops::Element<T1>>,
        ) -> Arg<crate::sui::group_ops::Element<T2>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pairing").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn set_as_prefix<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<bool>,
            p2: MutRef<'a, Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_as_prefix").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn sub<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, crate::sui::group_ops::Element<T0>>,
            p2: Ref<'a, crate::sui::group_ops::Element<T0>>,
        ) -> Arg<crate::sui::group_ops::Element<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sub").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn sum<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Ref<'a, Vec<crate::sui::group_ops::Element<T0>>>,
        ) -> Arg<crate::sui::group_ops::Element<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sum").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod hash {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "hash";
        pub fn blake2b256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("blake2b256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn keccak256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("keccak256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod hex {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "hex";
        pub fn decode(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("decode").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn decode_byte(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("decode_byte").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn encode(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("encode").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod hmac {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "hmac";
        pub fn hmac_sha3_256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hmac_sha3_256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod kiosk {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "kiosk";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Borrow {
            pub kiosk_id: ObjectId,
            pub item_id: ObjectId,
        }
        impl Borrow {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Item {
            pub id: ObjectId,
        }
        impl Item {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ItemDelisted<T0> {
            pub kiosk: ObjectId,
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ItemDelisted<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ItemListed<T0> {
            pub kiosk: ObjectId,
            pub id: ObjectId,
            pub price: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ItemListed<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ItemPurchased<T0> {
            pub kiosk: ObjectId,
            pub id: ObjectId,
            pub price: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ItemPurchased<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Kiosk {
            pub id: ObjectId,
            pub profits: crate::sui::balance::Balance<crate::sui::sui::SUI>,
            pub owner: Address,
            pub item_count: u32,
            pub allow_extensions: bool,
        }
        impl Kiosk {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct KioskOwnerCap {
            pub id: ObjectId,
            pub for_: ObjectId,
        }
        impl KioskOwnerCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Listing {
            pub id: ObjectId,
            pub is_exclusive: bool,
        }
        impl Listing {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Lock {
            pub id: ObjectId,
        }
        impl Lock {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct PurchaseCap<T0> {
            pub id: ObjectId,
            pub kiosk_id: ObjectId,
            pub item_id: ObjectId,
            pub min_price: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> PurchaseCap<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn borrow<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn borrow_val<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_val").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn close_and_withdraw<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::kiosk::Kiosk>,
            p1: Arg<crate::sui::kiosk::KioskOwnerCap>,
        ) -> Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("close_and_withdraw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn default<'a>(builder: &mut sui_transaction_builder::TransactionBuilder) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("default").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
        pub fn delist<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delist").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn has_access<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_access").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_item<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_item").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_item_with_type<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_item_with_type").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_listed<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_listed").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_listed_exclusively<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_listed_exclusively").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_locked<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_locked").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn item_count<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("item_count").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn kiosk_owner_cap_for<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("kiosk_owner_cap_for").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn list<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
            p3: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("list").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn list_with_purchase_cap<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
            p3: Arg<u64>,
        ) -> Arg<crate::sui::kiosk::PurchaseCap<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("list_with_purchase_cap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn lock<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p3: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("lock").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn lock_internal<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("lock_internal").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::kiosk::Kiosk> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn place<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("place").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn place_and_list<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<T0>,
            p3: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("place_and_list").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn place_internal<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("place_internal").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn profits_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("profits_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn profits_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) -> MutRef<'a, crate::sui::balance::Balance<crate::sui::sui::SUI>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("profits_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn purchase<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("purchase").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn purchase_cap_item<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::PurchaseCap<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("purchase_cap_item").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn purchase_cap_kiosk<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::PurchaseCap<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("purchase_cap_kiosk").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn purchase_cap_min_price<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::PurchaseCap<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("purchase_cap_min_price").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn purchase_with_cap<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<crate::sui::kiosk::PurchaseCap<T0>>,
            p2: Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("purchase_with_cap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn return_purchase_cap<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<crate::sui::kiosk::PurchaseCap<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("return_purchase_cap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn return_val<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Arg<T0>,
            p2: Arg<crate::sui::kiosk::Borrow>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("return_val").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_allow_extensions<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<bool>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_allow_extensions").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_owner_custom<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_owner_custom").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn take<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<ObjectId>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("take").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn uid<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
        ) -> MutRef<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_mut_as_owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) -> MutRef<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_mut_as_owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn uid_mut_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
        ) -> MutRef<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_mut_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn withdraw<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p2: Arg<Option<u64>>,
        ) -> Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
    pub mod kiosk_extension {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "kiosk_extension";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Extension {
            pub storage: crate::sui::bag::Bag,
            pub permissions: u128,
            pub is_enabled: bool,
        }
        impl Extension {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ExtensionKey<T0> {
            pub dummy_field: bool,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ExtensionKey<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p2: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
            p3: Arg<u128>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn can_lock<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("can_lock").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn can_place<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("can_place").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn disable<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("disable").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn enable<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("enable").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn extension<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Ref<'a, crate::sui::kiosk_extension::Extension> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extension").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extension_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
        ) -> MutRef<'a, crate::sui::kiosk_extension::Extension> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extension_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_enabled<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_enabled").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_installed<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_installed").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn lock<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p2: Arg<T1>,
            p3: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("lock").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn place<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p2: Arg<T1>,
            p3: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("place").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::kiosk::Kiosk>,
            p1: Ref<'a, crate::sui::kiosk::KioskOwnerCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn storage<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Ref<'a, crate::sui::kiosk::Kiosk>,
        ) -> Ref<'a, crate::sui::bag::Bag> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn storage_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: MutRef<'a, crate::sui::kiosk::Kiosk>,
        ) -> MutRef<'a, crate::sui::bag::Bag> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod linked_table {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "linked_table";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct LinkedTable<T0, T1> {
            pub id: ObjectId,
            pub size: u64,
            pub head: Option<T0>,
            pub tail: Option<T0>,
            phantom_data_1: std::marker::PhantomData<T1>,
        }
        impl<T0, T1> LinkedTable<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Node<T0, T1> {
            pub prev: Option<T0>,
            pub next: Option<T0>,
            pub value: T1,
        }
        impl<T0, T1> Node<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn back<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Ref<'a, Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("back").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn borrow<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn drop<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("drop").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn front<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Ref<'a, Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("front").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::linked_table::LinkedTable<T0, T1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn next<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Ref<'a, Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("next").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pop_back<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_back").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pop_front<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_front").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn prev<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Ref<'a, Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("prev").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn push_back<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("push_back").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn push_front<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("push_front").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn remove<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::linked_table::LinkedTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod math {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "math";
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u8>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn sqrt_u128(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod nitro_attestation {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "nitro_attestation";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct NitroAttestationDocument {
            pub module_id: Vec<u8>,
            pub timestamp: u64,
            pub digest: Vec<u8>,
            pub pcrs: Vec<crate::sui::nitro_attestation::PCREntry>,
            pub public_key: Option<Vec<u8>>,
            pub user_data: Option<Vec<u8>>,
            pub nonce: Option<Vec<u8>>,
        }
        impl NitroAttestationDocument {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PCREntry {
            pub index: u8,
            pub value: Vec<u8>,
        }
        impl PCREntry {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn digest<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("digest").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn index<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::PCREntry>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("index").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn load_nitro_attestation<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
            p1: Ref<'a, crate::sui::clock::Clock>,
        ) -> Arg<crate::sui::nitro_attestation::NitroAttestationDocument> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_nitro_attestation").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn load_nitro_attestation_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::nitro_attestation::NitroAttestationDocument> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_nitro_attestation_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn module_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("module_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn nonce<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Option<Vec<u8>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("nonce").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pcrs<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Vec<crate::sui::nitro_attestation::PCREntry>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pcrs").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Option<Vec<u8>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn timestamp<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("timestamp").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn user_data<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::NitroAttestationDocument>,
        ) -> Ref<'a, Option<Vec<u8>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("user_data").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn value<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::nitro_attestation::PCREntry>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod object {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "object";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ID {
            pub bytes: Address,
        }
        impl ID {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UID {
            pub id: ObjectId,
        }
        impl UID {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn authenticator_state(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authenticator_state").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn borrow_id<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_id").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn borrow_uid<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_uid").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn bridge(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bridge").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn clock(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("clock").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn delete(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn delete_impl(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_impl").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn id<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_address<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_address").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_bytes<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_bytes").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_from_address(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_from_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_to_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_to_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn id_to_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id_to_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn new_uid_from_hash(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_uid_from_hash").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn randomness_state(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("randomness_state").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn record_new_uid(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("record_new_uid").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn sui_deny_list_object_id(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sui_deny_list_object_id").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn sui_system_state<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<ObjectId> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sui_system_state").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn uid_as_inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_as_inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_to_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_to_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_to_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_to_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_to_inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, ObjectId>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_to_inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod object_bag {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "object_bag";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct ObjectBag {
            pub id: ObjectId,
            pub size: u64,
        }
        impl ObjectBag {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains_with_type<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains_with_type").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::object_bag::ObjectBag>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::object_bag::ObjectBag> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn value_id<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_bag::ObjectBag>,
            p1: Arg<T0>,
        ) -> Arg<Option<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value_id").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod object_table {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "object_table";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct ObjectTable<T0, T1> {
            pub id: ObjectId,
            pub size: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
            phantom_data_1: std::marker::PhantomData<T1>,
        }
        impl<T0, T1> ObjectTable<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::object_table::ObjectTable<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn is_empty<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::object_table::ObjectTable<T0, T1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn value_id<'a, T0: MoveType, T1: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::object_table::ObjectTable<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<Option<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value_id").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod package {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "package";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Publisher {
            pub id: ObjectId,
            pub package: String,
            pub module_name: String,
        }
        impl Publisher {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct UpgradeCap {
            pub id: ObjectId,
            pub package: ObjectId,
            pub version: u64,
            pub policy: u8,
        }
        impl UpgradeCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UpgradeReceipt {
            pub cap: ObjectId,
            pub package: ObjectId,
        }
        impl UpgradeReceipt {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UpgradeTicket {
            pub cap: ObjectId,
            pub package: ObjectId,
            pub policy: u8,
            pub digest: Vec<u8>,
        }
        impl UpgradeTicket {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn additive_policy(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u8> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("additive_policy").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn authorize_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::package::UpgradeCap>,
            p1: Arg<u8>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::package::UpgradeTicket> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authorize_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn burn_publisher(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::package::Publisher>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("burn_publisher").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn claim<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::sui::package::Publisher> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("claim").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn claim_and_keep<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("claim_and_keep").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn commit_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::package::UpgradeCap>,
            p1: Arg<crate::sui::package::UpgradeReceipt>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("commit_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn compatible_policy(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u8> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("compatible_policy").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn dep_only_policy(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u8> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("dep_only_policy").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn from_module<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_module").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_package<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_package").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn make_immutable(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::package::UpgradeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("make_immutable").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn only_additive_upgrades<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::package::UpgradeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("only_additive_upgrades").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn only_dep_upgrades<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::package::UpgradeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("only_dep_upgrades").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn published_module<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("published_module").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn published_package<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("published_package").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn receipt_cap<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeReceipt>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("receipt_cap").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn receipt_package<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeReceipt>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("receipt_package").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn restrict<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::package::UpgradeCap>,
            p1: Arg<u8>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("restrict").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn ticket_digest<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeTicket>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ticket_digest").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ticket_package<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeTicket>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ticket_package").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ticket_policy<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeTicket>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ticket_policy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn upgrade_package<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeCap>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("upgrade_package").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn upgrade_policy<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeCap>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("upgrade_policy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn version<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::UpgradeCap>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("version").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod party {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "party";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Party {
            pub default: crate::sui::party::Permissions,
            pub members: crate::sui::vec_map::VecMap<
                Address,
                crate::sui::party::Permissions,
            >,
        }
        impl Party {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Permissions {
            pub pos0: u64,
        }
        impl Permissions {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::party::Party> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn into_native(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::party::Party>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_native").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_single_owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::party::Party>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_single_owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn set_permissions<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::party::Party>,
            p1: Arg<Address>,
            p2: Arg<crate::sui::party::Permissions>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_permissions").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn single_owner(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<crate::sui::party::Party> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("single_owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod pay {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "pay";
        pub fn divide_and_keep<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_keep").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn join<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<crate::sui::coin::Coin<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn join_vec<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<Vec<crate::sui::coin::Coin<T0>>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join_vec").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn join_vec_and_transfer<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<crate::sui::coin::Coin<T0>>>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join_vec_and_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn keep<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::Coin<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("keep").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn split<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn split_and_transfer<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<u64>,
            p2: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split_and_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn split_vec<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::Coin<T0>>,
            p1: Arg<Vec<u64>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split_vec").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod poseidon {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "poseidon";
        pub fn poseidon_bn254<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<move_types::U256>>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("poseidon_bn254").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn poseidon_bn254_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<Vec<u8>>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("poseidon_bn254_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod priority_queue {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "priority_queue";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Entry<T0> {
            pub priority: u64,
            pub value: T0,
        }
        impl<T0> Entry<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PriorityQueue<T0> {
            pub entries: Vec<crate::sui::priority_queue::Entry<T0>>,
        }
        impl<T0> PriorityQueue<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn create_entries<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u64>>,
            p1: Arg<Vec<T0>>,
        ) -> Arg<Vec<crate::sui::priority_queue::Entry<T0>>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_entries").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::priority_queue::PriorityQueue<T0>>,
            p1: Arg<u64>,
            p2: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn max_heapify_recursive<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<crate::sui::priority_queue::Entry<T0>>>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max_heapify_recursive").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn new<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<crate::sui::priority_queue::Entry<T0>>>,
        ) -> Arg<crate::sui::priority_queue::PriorityQueue<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_entry<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<T0>,
        ) -> Arg<crate::sui::priority_queue::Entry<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_entry").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pop_max<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::priority_queue::PriorityQueue<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_max").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn priorities<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::priority_queue::PriorityQueue<T0>>,
        ) -> Arg<Vec<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("priorities").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn restore_heap_recursive<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<crate::sui::priority_queue::Entry<T0>>>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("restore_heap_recursive").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod random {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "random";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Random {
            pub id: ObjectId,
            pub inner: crate::sui::versioned::Versioned,
        }
        impl Random {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct RandomGenerator {
            pub seed: Vec<u8>,
            pub counter: u16,
            pub buffer: Vec<u8>,
        }
        impl RandomGenerator {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct RandomInner {
            pub version: u64,
            pub epoch: u64,
            pub randomness_round: u64,
            pub random_bytes: Vec<u8>,
        }
        impl RandomInner {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn create<'a>(builder: &mut sui_transaction_builder::TransactionBuilder) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
        pub fn derive_next_block<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("derive_next_block").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_bool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_bool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u16>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn generate_u128<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u128_in_range<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u128>,
            p2: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u128_in_range").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn generate_u16<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u16_in_range<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u16>,
            p2: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u16_in_range").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn generate_u256<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u32<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u32_in_range<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u32>,
            p2: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u32_in_range").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn generate_u64<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u64_in_range<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u64_in_range").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn generate_u8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn generate_u8_in_range<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: Arg<u8>,
            p2: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("generate_u8_in_range").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn load_inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::random::Random>,
        ) -> Ref<'a, crate::sui::random::RandomInner> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn load_inner_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::Random>,
        ) -> MutRef<'a, crate::sui::random::RandomInner> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_inner_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_generator<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::random::Random>,
        ) -> Arg<crate::sui::random::RandomGenerator> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_generator").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn shuffle<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::RandomGenerator>,
            p1: MutRef<'a, Vec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("shuffle").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn update_randomness_state<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::random::Random>,
            p1: Arg<u64>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_randomness_state").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
    }
    pub mod sui {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "sui";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct SUI {
            pub dummy_field: bool,
        }
        impl SUI {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::balance::Balance<crate::sui::sui::SUI>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn transfer(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod table {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "table";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Table<T0, T1> {
            pub id: ObjectId,
            pub size: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
            phantom_data_1: std::marker::PhantomData<T1>,
        }
        impl<T0, T1> Table<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table::Table<T0, T1>>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table::Table<T0, T1>>,
            p1: Arg<T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table::Table<T0, T1>>,
            p1: Arg<T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table::Table<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::table::Table<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn drop<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::table::Table<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("drop").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn is_empty<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table::Table<T0, T1>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table::Table<T0, T1>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::table::Table<T0, T1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table::Table<T0, T1>>,
            p1: Arg<T0>,
        ) -> Arg<T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod table_vec {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "table_vec";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TableVec<T0> {
            pub contents: crate::sui::table::Table<u64, T0>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TableVec<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn borrow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table_vec::TableVec<T0>>,
            p1: Arg<u64>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table_vec::TableVec<T0>>,
            p1: Arg<u64>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::table_vec::TableVec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn drop<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::table_vec::TableVec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("drop").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn empty<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::table_vec::TableVec<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn is_empty<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table_vec::TableVec<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::table_vec::TableVec<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pop_back<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table_vec::TableVec<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_back").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn push_back<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table_vec::TableVec<T0>>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("push_back").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn singleton<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::sui::table_vec::TableVec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("singleton").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn swap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table_vec::TableVec<T0>>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn swap_remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::table_vec::TableVec<T0>>,
            p1: Arg<u64>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap_remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod token {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "token";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ActionRequest<T0> {
            pub name: String,
            pub amount: u64,
            pub sender: Address,
            pub recipient: Option<Address>,
            pub spent_balance: Option<crate::sui::balance::Balance<T0>>,
            pub approvals: crate::sui::vec_set::VecSet<String>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ActionRequest<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct RuleKey<T0> {
            pub is_protected: bool,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> RuleKey<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Token<T0> {
            pub id: ObjectId,
            pub balance: crate::sui::balance::Balance<T0>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Token<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct TokenPolicy<T0> {
            pub id: ObjectId,
            pub spent_balance: crate::sui::balance::Balance<T0>,
            pub rules: crate::sui::vec_map::VecMap<
                String,
                crate::sui::vec_set::VecSet<String>,
            >,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TokenPolicy<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct TokenPolicyCap<T0> {
            pub id: ObjectId,
            pub for_: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TokenPolicyCap<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TokenPolicyCreated<T0> {
            pub id: ObjectId,
            pub is_mutable: bool,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TokenPolicyCreated<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn action<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("action").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn add_approval<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::token::ActionRequest<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_approval").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn add_rule_config<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p2: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p3: Arg<T2>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_rule_config").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn add_rule_for_action<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_rule_for_action").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn allow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("allow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn amount<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("amount").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn approvals<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<crate::sui::vec_set::VecSet<String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("approvals").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn burn<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<crate::sui::token::Token<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("burn").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn confirm_request<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Arg<crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("confirm_request").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn confirm_request_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Arg<crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("confirm_request_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn confirm_with_policy_cap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p1: Arg<crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("confirm_with_policy_cap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn confirm_with_treasury_cap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("confirm_with_treasury_cap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_zero<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::Token<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn disallow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("disallow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn flush<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("flush").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_coin<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::coin::Coin<T0>>,
        ) -> Arg<crate::sui::token::Token<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_coin").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_coin_action(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_coin_action").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn has_rule_config<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_rule_config").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn has_rule_config_with_type<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_rule_config_with_type").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_allowed<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_allowed").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn join<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::Token<T0>>,
            p1: Arg<crate::sui::token::Token<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn keep<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::Token<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("keep").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn key<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::token::RuleKey<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("key").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn mint<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::coin::TreasuryCap<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::token::Token<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mint").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn new_policy<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::coin::TreasuryCap<T0>>,
        ) -> Arg<crate::sui::token::TokenPolicy<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_policy").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_request<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
            p1: Arg<u64>,
            p2: Arg<Option<Address>>,
            p3: Arg<Option<crate::sui::balance::Balance<T0>>>,
        ) -> Arg<crate::sui::token::ActionRequest<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_request").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn recipient<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<Option<Address>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("recipient").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove_rule_config<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
        ) -> Arg<T2> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_rule_config").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_rule_for_action<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_rule_for_action").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn rule_config<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
        ) -> Ref<'a, T2> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rule_config").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn rule_config_mut<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::token::TokenPolicy<T0>>,
            p2: Ref<'a, crate::sui::token::TokenPolicyCap<T0>>,
        ) -> MutRef<'a, T2> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rule_config_mut").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn rules<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
            p1: Ref<'a, String>,
        ) -> Arg<crate::sui::vec_set::VecSet<String>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rules").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sender<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sender").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn share_policy<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::TokenPolicy<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("share_policy").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn spend<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::Token<T0>>,
        ) -> Arg<crate::sui::token::ActionRequest<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("spend").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn spend_action(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("spend_action").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn spent<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::ActionRequest<T0>>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("spent").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn spent_balance<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::TokenPolicy<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("spent_balance").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn split<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::token::Token<T0>>,
            p1: Arg<u64>,
        ) -> Arg<crate::sui::token::Token<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn to_coin<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::Token<T0>>,
        ) -> Arg<crate::sui::coin::Coin<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_coin").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_coin_action(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_coin_action").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn transfer<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::token::Token<T0>>,
            p1: Arg<Address>,
        ) -> Arg<crate::sui::token::ActionRequest<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn transfer_action(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer_action").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn value<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::token::Token<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn zero<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::token::Token<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("zero").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
    }
    pub mod transfer {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "transfer";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Receiving<T0> {
            pub id: ObjectId,
            pub version: u64,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> Receiving<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn freeze_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("freeze_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn freeze_object_impl<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("freeze_object_impl").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn party_transfer<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<crate::sui::party::Party>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("party_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn party_transfer_impl<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<u64>,
            p2: Arg<Vec<Address>>,
            p3: Arg<Vec<u64>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("party_transfer_impl").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn public_freeze_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_freeze_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn public_party_transfer<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<crate::sui::party::Party>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_party_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn public_receive<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<crate::sui::transfer::Receiving<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_receive").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn public_share_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_share_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn public_transfer<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn receive<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, ObjectId>,
            p1: Arg<crate::sui::transfer::Receiving<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("receive").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn receive_impl<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("receive_impl").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn receiving_object_id<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer::Receiving<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("receiving_object_id").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn share_object<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("share_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn share_object_impl<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("share_object_impl").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn transfer<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn transfer_impl<T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
            p1: Arg<Address>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transfer_impl").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod transfer_policy {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "transfer_policy";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct RuleKey<T0> {
            pub dummy_field: bool,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> RuleKey<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct TransferPolicy<T0> {
            pub id: ObjectId,
            pub balance: crate::sui::balance::Balance<crate::sui::sui::SUI>,
            pub rules: crate::sui::vec_set::VecSet<String>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TransferPolicy<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct TransferPolicyCap<T0> {
            pub id: ObjectId,
            pub policy_id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TransferPolicyCap<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TransferPolicyCreated<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TransferPolicyCreated<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TransferPolicyDestroyed<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TransferPolicyDestroyed<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TransferRequest<T0> {
            pub item: ObjectId,
            pub paid: u64,
            pub from: ObjectId,
            pub receipts: crate::sui::vec_set::VecSet<String>,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> TransferRequest<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn add_receipt<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::transfer_policy::TransferRequest<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_receipt").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn add_rule<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p2: Ref<'a, crate::sui::transfer_policy::TransferPolicyCap<T0>>,
            p3: Arg<T2>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_rule").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn add_to_balance<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: MutRef<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p2: Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_to_balance").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn confirm_request<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p1: Arg<crate::sui::transfer_policy::TransferRequest<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("confirm_request").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn default<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("default").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn destroy_and_withdraw<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::transfer_policy::TransferPolicy<T0>>,
            p1: Arg<crate::sui::transfer_policy::TransferPolicyCap<T0>>,
        ) -> Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_and_withdraw").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferRequest<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_rule<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T1>,
            p1: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
        ) -> Ref<'a, T2> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_rule").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_rule<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_rule").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn item<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferRequest<T0>>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("item").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<crate::sui::transfer_policy::TransferPolicy<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_request<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
            p1: Arg<u64>,
            p2: Arg<ObjectId>,
        ) -> Arg<crate::sui::transfer_policy::TransferRequest<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_request").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn paid<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferRequest<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("paid").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove_rule<'a, T0: MoveType, T1: MoveType, T2: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p1: Ref<'a, crate::sui::transfer_policy::TransferPolicyCap<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_rule").unwrap(),
                        vec![T0::type_(), T1::type_(), T2::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn rules<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
        ) -> Ref<'a, crate::sui::vec_set::VecSet<String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rules").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
        ) -> Ref<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn uid_mut_as_owner<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p1: Ref<'a, crate::sui::transfer_policy::TransferPolicyCap<T0>>,
        ) -> MutRef<'a, ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("uid_mut_as_owner").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn withdraw<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::transfer_policy::TransferPolicy<T0>>,
            p1: Ref<'a, crate::sui::transfer_policy::TransferPolicyCap<T0>>,
            p2: Arg<Option<u64>>,
        ) -> Arg<crate::sui::coin::Coin<crate::sui::sui::SUI>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
    pub mod tx_context {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "tx_context";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TxContext {
            pub sender: Address,
            pub tx_hash: Vec<u8>,
            pub epoch: u64,
            pub epoch_timestamp_ms: u64,
            pub ids_created: u64,
        }
        impl TxContext {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn derive_id(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
            p1: Arg<u64>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("derive_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn digest<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Ref<'a, Vec<u8>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("digest").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn epoch_timestamp_ms<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch_timestamp_ms").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn fresh_id(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Address> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fresh_id").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn fresh_object_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Address> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fresh_object_address").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn ids_created<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ids_created").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_epoch(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_epoch").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_epoch_timestamp_ms(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_epoch_timestamp_ms").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_gas_budget(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_gas_budget").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_gas_price(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_gas_price").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_ids_created(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_ids_created").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_sender(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Address> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_sender").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn native_sponsor(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Vec<Address>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("native_sponsor").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn option_sponsor(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Option<Address>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("option_sponsor").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn sender<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Address> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sender").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn sponsor<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Option<Address>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sponsor").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
    }
    pub mod types {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "types";
        pub fn is_one_time_witness<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_one_time_witness").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod url {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "url";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Url {
            pub url: String,
        }
        impl Url {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn inner_url<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::url::Url>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner_url").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_unsafe(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<crate::sui::url::Url> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_unsafe").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_unsafe_from_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::url::Url> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_unsafe_from_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::url::Url>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod vdf {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "vdf";
        pub fn hash_to_input<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_to_input").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn hash_to_input_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("hash_to_input_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn vdf_verify<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("vdf_verify").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn vdf_verify_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("vdf_verify_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
    }
    pub mod vec_map {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "vec_map";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Entry<T0, T1> {
            pub key: T0,
            pub value: T1,
        }
        impl<T0, T1> Entry<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct VecMap<T0, T1> {
            pub contents: Vec<crate::sui::vec_map::Entry<T0, T1>>,
        }
        impl<T0, T1> VecMap<T0, T1> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn contains<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::vec_map::VecMap<T0, T1>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn empty<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::vec_map::VecMap<T0, T1>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn from_keys_values<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<T0>>,
            p1: Arg<Vec<T1>>,
        ) -> Arg<crate::sui::vec_map::VecMap<T0, T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_keys_values").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Ref<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_entry_by_idx<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Arg<u64>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_entry_by_idx").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_entry_by_idx_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Arg<u64>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_entry_by_idx_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_idx<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_idx").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_idx_opt<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_idx_opt").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_mut<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> MutRef<'a, T1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_mut").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Arg<T0>,
            p2: Arg<T1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn into_keys_values<T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::vec_map::VecMap<T0, T1>>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_keys_values").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn keys<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("keys").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pop<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_entry_by_idx<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Arg<u64>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_entry_by_idx").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn size<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_get<'a, T0: MoveType, T1: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_map::VecMap<T0, T1>>,
            p1: Ref<'a, T0>,
        ) -> Arg<Option<T1>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_get").unwrap(),
                        vec![T0::type_(), T1::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod vec_set {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "vec_set";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct VecSet<T0> {
            pub contents: Vec<T0>,
        }
        impl<T0> VecSet<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn empty<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::sui::vec_set::VecSet<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn from_keys<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<T0>>,
        ) -> Arg<crate::sui::vec_set::VecSet<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_keys").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_idx<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_idx").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_idx_opt<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_idx_opt").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_set::VecSet<T0>>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn into_keys<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::vec_set::VecSet<T0>>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_keys").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn keys<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
        ) -> Ref<'a, Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("keys").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::vec_set::VecSet<T0>>,
            p1: Ref<'a, T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn singleton<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::sui::vec_set::VecSet<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("singleton").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn size<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::vec_set::VecSet<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod versioned {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "versioned";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct VersionChangeCap {
            pub versioned_id: ObjectId,
            pub old_version: u64,
        }
        impl VersionChangeCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Versioned {
            pub id: ObjectId,
            pub version: u64,
        }
        impl Versioned {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn create<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<T0>,
        ) -> Arg<crate::sui::versioned::Versioned> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::versioned::Versioned>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn load_value<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::versioned::Versioned>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_value").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn load_value_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::versioned::Versioned>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("load_value_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove_value_for_upgrade<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::versioned::Versioned>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_value_for_upgrade").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn upgrade<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::versioned::Versioned>,
            p1: Arg<u64>,
            p2: Arg<T0>,
            p3: Arg<crate::sui::versioned::VersionChangeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("upgrade").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn version<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::versioned::Versioned>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("version").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod zklogin_verified_id {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "zklogin_verified_id";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct VerifiedID {
            pub id: ObjectId,
            pub owner: Address,
            pub key_claim_name: String,
            pub key_claim_value: String,
            pub issuer: String,
            pub audience: String,
        }
        impl VerifiedID {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn audience<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_id::VerifiedID>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("audience").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn check_zklogin_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Ref<'a, String>,
            p2: Ref<'a, String>,
            p3: Ref<'a, String>,
            p4: Ref<'a, String>,
            p5: Arg<move_types::U256>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_zklogin_id").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                )
                .into()
        }
        pub fn check_zklogin_id_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Ref<'a, Vec<u8>>,
            p4: Ref<'a, Vec<u8>>,
            p5: Arg<move_types::U256>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_zklogin_id_internal").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                )
                .into()
        }
        pub fn delete(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::zklogin_verified_id::VerifiedID>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn issuer<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_id::VerifiedID>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("issuer").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn key_claim_name<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_id::VerifiedID>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("key_claim_name").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn key_claim_value<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_id::VerifiedID>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("key_claim_value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_id::VerifiedID>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn verify_zklogin_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
            p1: Arg<String>,
            p2: Arg<String>,
            p3: Arg<String>,
            p4: Arg<move_types::U256>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_zklogin_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
    }
    pub mod zklogin_verified_issuer {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 2u8,
        ]);
        pub const MODULE_NAME: &str = "zklogin_verified_issuer";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct VerifiedIssuer {
            pub id: ObjectId,
            pub owner: Address,
            pub issuer: String,
        }
        impl VerifiedIssuer {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 2u8,
            ]);
        }
        pub fn check_zklogin_issuer<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<move_types::U256>,
            p2: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_zklogin_issuer").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn check_zklogin_issuer_internal<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
            p1: Arg<move_types::U256>,
            p2: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_zklogin_issuer_internal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn delete(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::zklogin_verified_issuer::VerifiedIssuer>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn issuer<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_issuer::VerifiedIssuer>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("issuer").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn owner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::zklogin_verified_issuer::VerifiedIssuer>,
        ) -> Arg<Address> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("owner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn verify_zklogin_issuer<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_zklogin_issuer").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
}
