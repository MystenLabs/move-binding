---
source: move-binding/tests/snapshot_tests.rs
expression: pretty
---
pub mod walrus {
    pub const PACKAGE_VERSION: u64 = 1u64;
    pub mod active_set {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "active_set";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ActiveSet {
            pub max_size: u16,
            pub threshold_stake: u64,
            pub nodes: Vec<crate::walrus::active_set::ActiveSetEntry>,
            pub total_stake: u64,
        }
        impl ActiveSet {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ActiveSetEntry {
            pub node_id: ObjectId,
            pub staked_amount: u64,
        }
        impl ActiveSetEntry {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn active_ids<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<Vec<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("active_ids").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn active_ids_and_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<Vec<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("active_ids_and_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn insert<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::active_set::ActiveSet>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn insert_or_update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::active_set::ActiveSet>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert_or_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn max_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u64>,
        ) -> Arg<crate::walrus::active_set::ActiveSet> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::active_set::ActiveSet>,
            p1: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn threshold_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("threshold_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn total_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::active_set::ActiveSet>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("total_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::active_set::ActiveSet>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
    pub mod apportionment_queue {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "apportionment_queue";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ApportionmentQueue<T0> {
            pub entries: Vec<crate::walrus::apportionment_queue::Entry<T0>>,
        }
        impl<T0> ApportionmentQueue<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Entry<T0> {
            pub priority: crate::move_lib::uq64_64::UQ64_64,
            pub tie_breaker: u64,
            pub value: T0,
        }
        impl<T0> Entry<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn bubble_down<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<crate::walrus::apportionment_queue::Entry<T0>>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bubble_down").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn bubble_up<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<crate::walrus::apportionment_queue::Entry<T0>>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bubble_up").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn higher_priority_than<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::apportionment_queue::Entry<T0>>,
            p1: Ref<'a, crate::walrus::apportionment_queue::Entry<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("higher_priority_than").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::apportionment_queue::ApportionmentQueue<T0>>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p2: Arg<u64>,
            p3: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn new<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::apportionment_queue::ApportionmentQueue<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn pop_max<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::apportionment_queue::ApportionmentQueue<T0>>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_max").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod auth {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "auth";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum Authenticated {
            Sender(Address),
            Object(ObjectId),
        }
        impl Authenticated {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum Authorized {
            Address(Address),
            ObjectID(ObjectId),
        }
        impl Authorized {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn authenticate_sender<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::auth::Authenticated> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authenticate_sender").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn authenticate_with_object<'a, T0: move_types::Key>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<crate::walrus::auth::Authenticated> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authenticate_with_object").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn authorized_address(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Address>,
        ) -> Arg<crate::walrus::auth::Authorized> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authorized_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn authorized_object(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
        ) -> Arg<crate::walrus::auth::Authorized> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authorized_object").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn matches<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::auth::Authenticated>,
            p1: Ref<'a, crate::walrus::auth::Authorized>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("matches").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod blob {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "blob";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Blob {
            pub id: ObjectId,
            pub registered_epoch: u32,
            pub blob_id: move_types::U256,
            pub size: u64,
            pub encoding_type: u8,
            pub certified_epoch: Option<u32>,
            pub storage: crate::walrus::storage_resource::Storage,
            pub deletable: bool,
        }
        impl Blob {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlobIdDerivation {
            pub encoding_type: u8,
            pub size: u64,
            pub root_hash: move_types::U256,
        }
        impl BlobIdDerivation {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn add_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Arg<crate::walrus::metadata::Metadata>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn add_or_replace_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Arg<crate::walrus::metadata::Metadata>,
        ) -> Arg<Option<crate::walrus::metadata::Metadata>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_or_replace_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn assert_certified_not_expired<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
            p1: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("assert_certified_not_expired").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn burn(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::blob::Blob>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("burn").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn certified_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Ref<'a, Option<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certified_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn certify_with_certified_msg<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Arg<u32>,
            p2: Arg<crate::walrus::messages::CertifiedBlobMessage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_with_certified_msg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn delete(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::blob::Blob>,
            p1: Arg<u32>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn derive_blob_id(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<u8>,
            p2: Arg<u64>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("derive_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn emit_certified<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
            p1: Arg<bool>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_certified").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn encoded_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
            p1: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("encoded_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn encoding_type<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("encoding_type").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn end_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("end_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extend_with_resource<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
            p2: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_with_resource").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn insert_or_update_metadata_pair<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert_or_update_metadata_pair").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn is_deletable<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_deletable").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
        ) -> MutRef<'a, crate::walrus::metadata::Metadata> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn metadata_or_create<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
        ) -> MutRef<'a, crate::walrus::metadata::Metadata> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("metadata_or_create").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::storage_resource::Storage>,
            p1: Arg<move_types::U256>,
            p2: Arg<move_types::U256>,
            p3: Arg<u64>,
            p4: Arg<u8>,
            p5: Arg<bool>,
            p6: Arg<u32>,
            p7: Arg<u16>,
        ) -> Arg<crate::walrus::blob::Blob> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into()
                    ],
                )
                .into()
        }
        pub fn object_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("object_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn registered_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("registered_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn remove_metadata_pair<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_metadata_pair").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_metadata_pair_if_exists<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
            p1: Ref<'a, String>,
        ) -> Arg<Option<String>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_metadata_pair_if_exists").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn storage<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::blob::Blob>,
        ) -> Ref<'a, crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn storage_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
        ) -> MutRef<'a, crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn take_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::blob::Blob>,
        ) -> Arg<crate::walrus::metadata::Metadata> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("take_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod bls_aggregate {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "bls_aggregate";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlsCommittee {
            pub members: Vec<crate::walrus::bls_aggregate::BlsCommitteeMember>,
            pub n_shards: u16,
            pub epoch: u32,
            pub total_aggregated_key: crate::sui::group_ops::Element<
                crate::sui::bls12381::G1,
            >,
        }
        impl BlsCommittee {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlsCommitteeMember {
            pub public_key: crate::sui::group_ops::Element<
                crate::sui::bls12381::UncompressedG1,
            >,
            pub weight: u16,
            pub node_id: ObjectId,
        }
        impl BlsCommitteeMember {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum RequiredWeight {
            Quorum,
            OneCorrectNode,
        }
        impl RequiredWeight {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn contains<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Ref<'a, ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn find_index<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Ref<'a, ObjectId>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("find_index").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_idx<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Arg<u64>,
        ) -> Ref<'a, crate::walrus::bls_aggregate::BlsCommitteeMember> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_idx").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_member_weight<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Ref<'a, ObjectId>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_member_weight").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn includes_one_correct_node<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Arg<u16>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("includes_one_correct_node").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_quorum<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Arg<u16>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_quorum").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn n_members<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_members").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn n_shards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_bls_committee(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Vec<crate::walrus::bls_aggregate::BlsCommitteeMember>>,
        ) -> Arg<crate::walrus::bls_aggregate::BlsCommittee> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_bls_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn new_bls_committee_member(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<
                crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
            >,
            p1: Arg<u16>,
            p2: Arg<ObjectId>,
        ) -> Arg<crate::walrus::bls_aggregate::BlsCommitteeMember> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_bls_committee_member").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn node_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommitteeMember>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_vec_map<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
        ) -> Arg<crate::sui::vec_map::VecMap<ObjectId, u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_vec_map").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn verify_certificate_and_weight<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Ref<'a, Vec<u8>>,
            p2: Ref<'a, Vec<u8>>,
            p3: Ref<'a, Vec<u8>>,
            p4: Arg<crate::walrus::bls_aggregate::RequiredWeight>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_certificate_and_weight").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                )
                .into()
        }
        pub fn verify_one_correct_node_in_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) -> Arg<crate::walrus::messages::CertifiedMessage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_one_correct_node_in_epoch")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn verify_quorum_in_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::bls_aggregate::BlsCommittee>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) -> Arg<crate::walrus::messages::CertifiedMessage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_quorum_in_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
    }
    pub mod committee {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "committee";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Committee {
            pub pos0: crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>,
        }
        impl Committee {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn contains<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
            p1: Ref<'a, ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn diff<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
            p1: Ref<'a, crate::walrus::committee::Committee>,
        ) -> Arg<Vec<ObjectId>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::committee::Committee> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn initialize(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::vec_map::VecMap<ObjectId, u16>>,
        ) -> Arg<crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("initialize").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
        ) -> Ref<'a, crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn shards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
            p1: Ref<'a, ObjectId>,
        ) -> Ref<'a, Vec<u16>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
        ) -> Arg<crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn transition<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::committee::Committee>,
            p1: Arg<crate::sui::vec_map::VecMap<ObjectId, u16>>,
        ) -> Arg<crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("transition").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod display {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "display";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct ObjectDisplay {
            pub id: ObjectId,
            pub inner: crate::sui::object_bag::ObjectBag,
        }
        impl ObjectDisplay {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PublisherKey {
            pub dummy_field: bool,
        }
        impl PublisherKey {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn create<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::package::Publisher>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn init_blob_display<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<crate::sui::display::Display<crate::walrus::blob::Blob>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("init_blob_display").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn init_staked_wal_display<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<crate::sui::display::Display<crate::walrus::staked_wal::StakedWal>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("init_staked_wal_display").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn init_storage_display<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::sui::package::Publisher>,
        ) -> Arg<
            crate::sui::display::Display<crate::walrus::storage_resource::Storage>,
        > {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("init_storage_display").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod encoding {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "encoding";
        pub fn encoded_blob_length(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u8>,
            p2: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("encoded_blob_length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
    pub mod epoch_parameters {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "epoch_parameters";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EpochParams {
            pub total_capacity_size: u64,
            pub storage_price_per_unit_size: u64,
            pub write_price_per_unit_size: u64,
        }
        impl EpochParams {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn capacity<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::epoch_parameters::EpochParams>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("capacity").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<crate::walrus::epoch_parameters::EpochParams> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn storage_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::epoch_parameters::EpochParams>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn write_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::epoch_parameters::EpochParams>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("write_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod event_blob {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "event_blob";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EventBlob {
            pub blob_id: move_types::U256,
            pub ending_checkpoint_sequence_number: u64,
        }
        impl EventBlob {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EventBlobAttestation {
            pub checkpoint_sequence_num: u64,
            pub epoch: u32,
        }
        impl EventBlobAttestation {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EventBlobCertificationState {
            pub latest_certified_blob: Option<crate::walrus::event_blob::EventBlob>,
            pub aggregate_weight_per_blob: crate::sui::vec_map::VecMap<
                crate::walrus::event_blob::EventBlob,
                u16,
            >,
        }
        impl EventBlobCertificationState {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlob>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn create_with_empty_state(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::event_blob::EventBlobCertificationState> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_with_empty_state").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn ending_checkpoint_sequence_number<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlob>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ending_checkpoint_sequence_number")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_latest_certified_blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobCertificationState>,
        ) -> Arg<Option<move_types::U256>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_latest_certified_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_latest_certified_checkpoint_sequence_number<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobCertificationState>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str(
                                "get_latest_certified_checkpoint_sequence_number",
                            )
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_num_tracked_blobs<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobCertificationState>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_num_tracked_blobs").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_blob_already_certified<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobCertificationState>,
            p1: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_blob_already_certified").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn last_attested_event_blob_checkpoint_seq_num<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobAttestation>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str(
                                "last_attested_event_blob_checkpoint_seq_num",
                            )
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn last_attested_event_blob_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::event_blob::EventBlobAttestation>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("last_attested_event_blob_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_attestation(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u32>,
        ) -> Arg<crate::walrus::event_blob::EventBlobAttestation> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_attestation").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn new_event_blob(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<move_types::U256>,
        ) -> Arg<crate::walrus::event_blob::EventBlob> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_event_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn reset<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::event_blob::EventBlobCertificationState>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reset").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn start_tracking_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::event_blob::EventBlobCertificationState>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("start_tracking_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn update_aggregate_weight<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::event_blob::EventBlobCertificationState>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
            p3: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_aggregate_weight").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn update_latest_certified_event_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::event_blob::EventBlobCertificationState>,
            p1: Arg<u64>,
            p2: Arg<move_types::U256>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_latest_certified_event_blob")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
    }
    pub mod events {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "events";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlobCertified {
            pub epoch: u32,
            pub blob_id: move_types::U256,
            pub end_epoch: u32,
            pub deletable: bool,
            pub object_id: ObjectId,
            pub is_extension: bool,
        }
        impl BlobCertified {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlobDeleted {
            pub epoch: u32,
            pub blob_id: move_types::U256,
            pub end_epoch: u32,
            pub object_id: ObjectId,
            pub was_certified: bool,
        }
        impl BlobDeleted {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BlobRegistered {
            pub epoch: u32,
            pub blob_id: move_types::U256,
            pub size: u64,
            pub encoding_type: u8,
            pub end_epoch: u32,
            pub deletable: bool,
            pub object_id: ObjectId,
        }
        impl BlobRegistered {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ContractUpgradeProposed {
            pub epoch: u32,
            pub package_digest: Vec<u8>,
        }
        impl ContractUpgradeProposed {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ContractUpgradeQuorumReached {
            pub epoch: u32,
            pub package_digest: Vec<u8>,
        }
        impl ContractUpgradeQuorumReached {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ContractUpgraded {
            pub epoch: u32,
            pub package_id: ObjectId,
            pub version: u64,
        }
        impl ContractUpgraded {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct DenyListBlobDeleted {
            pub epoch: u32,
            pub blob_id: move_types::U256,
        }
        impl DenyListBlobDeleted {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct DenyListUpdate {
            pub epoch: u32,
            pub root: move_types::U256,
            pub sequence_number: u64,
            pub node_id: ObjectId,
        }
        impl DenyListUpdate {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EpochChangeDone {
            pub epoch: u32,
        }
        impl EpochChangeDone {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EpochChangeStart {
            pub epoch: u32,
        }
        impl EpochChangeStart {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct EpochParametersSelected {
            pub next_epoch: u32,
        }
        impl EpochParametersSelected {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct InvalidBlobID {
            pub epoch: u32,
            pub blob_id: move_types::U256,
        }
        impl InvalidBlobID {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct RegisterDenyListUpdate {
            pub epoch: u32,
            pub root: move_types::U256,
            pub sequence_number: u64,
            pub node_id: ObjectId,
        }
        impl RegisterDenyListUpdate {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ShardRecoveryStart {
            pub epoch: u32,
            pub shards: Vec<u16>,
        }
        impl ShardRecoveryStart {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ShardsReceived {
            pub epoch: u32,
            pub shards: Vec<u16>,
        }
        impl ShardsReceived {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn emit_blob_certified(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
            p2: Arg<u32>,
            p3: Arg<bool>,
            p4: Arg<ObjectId>,
            p5: Arg<bool>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_blob_certified").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                );
        }
        pub fn emit_blob_deleted(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
            p2: Arg<u32>,
            p3: Arg<ObjectId>,
            p4: Arg<bool>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_blob_deleted").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn emit_blob_registered(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
            p3: Arg<u8>,
            p4: Arg<u32>,
            p5: Arg<bool>,
            p6: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_blob_registered").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into()
                    ],
                );
        }
        pub fn emit_contract_upgrade_proposed(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_contract_upgrade_proposed").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn emit_contract_upgrade_quorum_reached(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_contract_upgrade_quorum_reached")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn emit_contract_upgraded(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_contract_upgraded").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn emit_deny_list_update(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
            p3: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_deny_list_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn emit_deny_listed_blob_deleted(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_deny_listed_blob_deleted").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn emit_epoch_change_done(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_epoch_change_done").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn emit_epoch_change_start(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_epoch_change_start").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn emit_epoch_parameters_selected(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_epoch_parameters_selected").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn emit_invalid_blob_id(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_invalid_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn emit_register_deny_list_update(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
            p3: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_register_deny_list_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn emit_shard_recovery_start(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Vec<u16>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_shard_recovery_start").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn emit_shards_received(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Vec<u16>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("emit_shards_received").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod extended_field {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "extended_field";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct ExtendedField<T0> {
            pub id: ObjectId,
            phantom_data_0: std::marker::PhantomData<T0>,
        }
        impl<T0> ExtendedField<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Key {
            pub dummy_field: bool,
        }
        impl Key {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn borrow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::extended_field::ExtendedField<T0>>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::extended_field::ExtendedField<T0>>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::extended_field::ExtendedField<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<crate::walrus::extended_field::ExtendedField<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn swap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::extended_field::ExtendedField<T0>>,
            p1: Arg<T0>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod init {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "init";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct INIT {
            pub dummy_field: bool,
        }
        impl INIT {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct InitCap {
            pub id: ObjectId,
            pub publisher: crate::sui::package::Publisher,
        }
        impl InitCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn init<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::init::INIT>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("init").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn initialize_walrus<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::init::InitCap>,
            p1: Arg<crate::sui::package::UpgradeCap>,
            p2: Arg<u64>,
            p3: Arg<u64>,
            p4: Arg<u16>,
            p5: Arg<u32>,
            p6: Ref<'a, crate::sui::clock::Clock>,
        ) -> Arg<crate::walrus::upgrade::EmergencyUpgradeCap> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("initialize_walrus").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into()
                    ],
                )
                .into()
        }
        pub fn migrate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: MutRef<'a, crate::walrus::system::System>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("migrate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod messages {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "messages";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct CertifiedBlobMessage {
            pub blob_id: move_types::U256,
            pub blob_persistence_type: crate::walrus::messages::BlobPersistenceType,
        }
        impl CertifiedBlobMessage {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct CertifiedInvalidBlobId {
            pub blob_id: move_types::U256,
        }
        impl CertifiedInvalidBlobId {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct CertifiedMessage {
            pub intent_type: u8,
            pub intent_version: u8,
            pub cert_epoch: u32,
            pub message: Vec<u8>,
            pub stake_support: u16,
        }
        impl CertifiedMessage {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct DenyListBlobDeleted {
            pub blob_id: move_types::U256,
        }
        impl DenyListBlobDeleted {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct DenyListUpdateMessage {
            pub storage_node_id: ObjectId,
            pub deny_list_sequence_number: u64,
            pub deny_list_size: u64,
            pub deny_list_root: move_types::U256,
        }
        impl DenyListUpdateMessage {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct ProofOfPossessionMessage {
            pub intent_type: u8,
            pub intent_version: u8,
            pub intent_app: u8,
            pub epoch: u32,
            pub sui_address: Address,
            pub bls_key: Vec<u8>,
        }
        impl ProofOfPossessionMessage {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum BlobPersistenceType {
            Permanent,
            Deletable { object_id: ObjectId },
        }
        impl BlobPersistenceType {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::DenyListBlobDeleted>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn blob_persistence_type<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedBlobMessage>,
        ) -> Arg<crate::walrus::messages::BlobPersistenceType> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("blob_persistence_type").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn cert_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("cert_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn certified_blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedBlobMessage>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certified_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn certified_event_blob_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<crate::walrus::messages::CertifiedBlobMessage> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certified_event_blob_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn certify_blob_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<crate::walrus::messages::CertifiedBlobMessage> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_blob_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn deny_list_blob_deleted_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<crate::walrus::messages::DenyListBlobDeleted> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_blob_deleted_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn deny_list_update_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<crate::walrus::messages::DenyListUpdateMessage> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_update_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn intent_type<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("intent_type").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn intent_version<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("intent_version").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn into_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn invalid_blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedInvalidBlobId>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("invalid_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn invalid_blob_id_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<crate::walrus::messages::CertifiedInvalidBlobId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("invalid_blob_id_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_deletable<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::BlobPersistenceType>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_deletable").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn message<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedMessage>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_certified_message(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
            p1: Arg<u32>,
            p2: Arg<u16>,
        ) -> Arg<crate::walrus::messages::CertifiedMessage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_certified_message").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn new_proof_of_possession_msg(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<Address>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<crate::walrus::messages::ProofOfPossessionMessage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_proof_of_possession_msg").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn object_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::BlobPersistenceType>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("object_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn peel_blob_persistence_type<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::bcs::BCS>,
        ) -> Arg<crate::walrus::messages::BlobPersistenceType> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("peel_blob_persistence_type").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn root<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::DenyListUpdateMessage>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("root").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn sequence_number<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::DenyListUpdateMessage>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sequence_number").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::DenyListUpdateMessage>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn stake_support<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::CertifiedMessage>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("stake_support").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn storage_node_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::DenyListUpdateMessage>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage_node_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_bcs<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::ProofOfPossessionMessage>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_bcs").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn verify_proof_of_possession<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::messages::ProofOfPossessionMessage>,
            p1: Arg<Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("verify_proof_of_possession").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod metadata {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "metadata";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Metadata {
            pub metadata: crate::sui::vec_map::VecMap<String, String>,
        }
        impl Metadata {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn insert_or_update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::metadata::Metadata>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert_or_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::metadata::Metadata> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn remove<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::metadata::Metadata>,
            p1: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn remove_if_exists<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::metadata::Metadata>,
            p1: Ref<'a, String>,
        ) -> Arg<Option<String>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove_if_exists").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod node_metadata {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "node_metadata";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct NodeMetadata {
            pub image_url: String,
            pub project_url: String,
            pub description: String,
            pub extra_fields: crate::sui::vec_map::VecMap<String, String>,
        }
        impl NodeMetadata {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn default(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::node_metadata::NodeMetadata> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("default").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn description<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::node_metadata::NodeMetadata>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("description").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extra_fields<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::node_metadata::NodeMetadata>,
        ) -> Ref<'a, crate::sui::vec_map::VecMap<String, String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extra_fields").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn image_url<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::node_metadata::NodeMetadata>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("image_url").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
            p1: Arg<String>,
            p2: Arg<String>,
        ) -> Arg<crate::walrus::node_metadata::NodeMetadata> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn project_url<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::node_metadata::NodeMetadata>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("project_url").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn set_description<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::node_metadata::NodeMetadata>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_description").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_extra_fields<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::node_metadata::NodeMetadata>,
            p1: Arg<crate::sui::vec_map::VecMap<String, String>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_extra_fields").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_image_url<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::node_metadata::NodeMetadata>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_image_url").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_project_url<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::node_metadata::NodeMetadata>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_project_url").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod pending_values {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "pending_values";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PendingValues {
            pub pos0: crate::sui::vec_map::VecMap<u32, u64>,
        }
        impl PendingValues {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::pending_values::PendingValues> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn flush<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::pending_values::PendingValues>,
            p1: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("flush").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::pending_values::PendingValues>,
        ) -> Ref<'a, crate::sui::vec_map::VecMap<u32, u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn inner_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::pending_values::PendingValues>,
        ) -> MutRef<'a, crate::sui::vec_map::VecMap<u32, u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn insert_or_add<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::pending_values::PendingValues>,
            p1: Arg<u32>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert_or_add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn insert_or_replace<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::pending_values::PendingValues>,
            p1: Arg<u32>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert_or_replace").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::pending_values::PendingValues>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn reduce<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::pending_values::PendingValues>,
            p1: Arg<u32>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reduce").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn unwrap(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::pending_values::PendingValues>,
        ) -> Arg<crate::sui::vec_map::VecMap<u32, u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("unwrap").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn value_at<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::pending_values::PendingValues>,
            p1: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value_at").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod pool_exchange_rate {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "pool_exchange_rate";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum PoolExchangeRate {
            Flat,
            Variable { wal_amount: u128, share_amount: u128 },
        }
        impl PoolExchangeRate {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn convert_to_share_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::pool_exchange_rate::PoolExchangeRate>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("convert_to_share_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn convert_to_wal_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::pool_exchange_rate::PoolExchangeRate>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("convert_to_wal_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn flat(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<crate::walrus::pool_exchange_rate::PoolExchangeRate> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("flat").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<crate::walrus::pool_exchange_rate::PoolExchangeRate> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod redstuff {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "redstuff";
        pub fn encoded_blob_length(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("encoded_blob_length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max_byzantine(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max_byzantine").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn metadata_size(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("metadata_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn n_source_symbols(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_source_symbols").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn source_symbols_primary(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("source_symbols_primary").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn source_symbols_secondary(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("source_symbols_secondary").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn symbol_size(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("symbol_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod shared_blob {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "shared_blob";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct SharedBlob {
            pub id: ObjectId,
            pub blob: crate::walrus::blob::Blob,
            pub funds: crate::sui::balance::Balance<crate::wal::wal::WAL>,
        }
        impl SharedBlob {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn extend<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::shared_blob::SharedBlob>,
            p1: MutRef<'a, crate::walrus::system::System>,
            p2: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn fund<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::shared_blob::SharedBlob>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fund").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::blob::Blob>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn new_funded<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::blob::Blob>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_funded").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod staked_wal {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "staked_wal";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct StakedWal {
            pub id: ObjectId,
            pub state: crate::walrus::staked_wal::StakedWalState,
            pub node_id: ObjectId,
            pub principal: crate::sui::balance::Balance<crate::wal::wal::WAL>,
            pub activation_epoch: u32,
        }
        impl StakedWal {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum StakedWalState {
            Staked,
            Withdrawing { withdraw_epoch: u32 },
        }
        impl StakedWalState {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn activation_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("activation_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn can_withdraw_early<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
            p1: Arg<bool>,
            p2: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("can_withdraw_early").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn into_balance(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_balance").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_staked<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_staked").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_withdrawing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_withdrawing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn join<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
            p1: Arg<crate::walrus::staked_wal::StakedWal>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("join").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn mint<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
            p1: Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>>,
            p2: Arg<u32>,
        ) -> Arg<crate::walrus::staked_wal::StakedWal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mint").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn node_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn set_withdrawing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
            p1: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_withdrawing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn split<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
            p1: Arg<u64>,
        ) -> Arg<crate::walrus::staked_wal::StakedWal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn value<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn withdraw_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod staking {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "staking";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Staking {
            pub id: ObjectId,
            pub version: u64,
            pub package_id: ObjectId,
            pub new_package_id: Option<ObjectId>,
        }
        impl Staking {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn calculate_rewards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
            p3: Arg<u32>,
            p4: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("calculate_rewards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                )
                .into()
        }
        pub fn can_withdraw_staked_wal_early<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("can_withdraw_staked_wal_early").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn check_governance_authorization<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_governance_authorization").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn collect_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
        ) -> Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("collect_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn compute_next_committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
        ) -> Arg<crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("compute_next_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn create<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
            p2: Arg<u16>,
            p3: Arg<ObjectId>,
            p4: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn epoch_sync_done<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u32>,
            p3: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch_sync_done").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn get_current_node_weight<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_current_node_weight").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn initiate_epoch_change<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: MutRef<'a, crate::walrus::system::System>,
            p2: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("initiate_epoch_change").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
        ) -> Ref<'a, crate::walrus::staking_inner::StakingInnerV1> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn inner_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
        ) -> MutRef<'a, crate::walrus::staking_inner::StakingInnerV1> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_quorum<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Arg<u16>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_quorum").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn migrate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("migrate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
        ) -> Arg<crate::walrus::node_metadata::NodeMetadata> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn package_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("package_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn register_candidate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<String>,
            p2: Arg<String>,
            p3: Arg<crate::walrus::node_metadata::NodeMetadata>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Vec<u8>>,
            p6: Arg<Vec<u8>>,
            p7: Arg<u16>,
            p8: Arg<u64>,
            p9: Arg<u64>,
            p10: Arg<u64>,
        ) -> Arg<crate::walrus::storage_node::StorageNodeCap> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            let p8 = p8.resolve_arg(builder);
            let p9 = p9.resolve_arg(builder);
            let p10 = p10.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("register_candidate").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into(), p8.into(), p9.into(), p10.into()
                    ],
                )
                .into()
        }
        pub fn request_withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("request_withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_commission_receiver<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
            p3: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_commission_receiver").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_governance_authorized<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
            p3: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_governance_authorized").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_name<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_name").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_network_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_network_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_new_package_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_new_package_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_next_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u16>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_next_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_node_capacity_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_capacity_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<crate::walrus::node_metadata::NodeMetadata>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_storage_price_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_storage_price_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_write_price_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_write_price_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn stake_with_pool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
            p2: Arg<ObjectId>,
        ) -> Arg<crate::walrus::staked_wal::StakedWal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("stake_with_pool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn try_join_active_set<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_join_active_set").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn version<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking::Staking>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("version").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn voting_end<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("voting_end").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking::Staking>,
            p1: Arg<crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod staking_inner {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "staking_inner";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct StakingInnerV1 {
            pub n_shards: u16,
            pub epoch_duration: u64,
            pub first_epoch_start: u64,
            pub pools: crate::sui::object_table::ObjectTable<
                ObjectId,
                crate::walrus::staking_pool::StakingPool,
            >,
            pub epoch: u32,
            pub active_set: crate::walrus::extended_field::ExtendedField<
                crate::walrus::active_set::ActiveSet,
            >,
            pub next_committee: Option<crate::walrus::committee::Committee>,
            pub committee: crate::walrus::committee::Committee,
            pub previous_committee: crate::walrus::committee::Committee,
            pub next_epoch_params: Option<crate::walrus::epoch_parameters::EpochParams>,
            pub epoch_state: crate::walrus::staking_inner::EpochState,
            pub next_epoch_public_keys: crate::walrus::extended_field::ExtendedField<
                crate::sui::vec_map::VecMap<
                    ObjectId,
                    crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
                >,
            >,
        }
        impl StakingInnerV1 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum EpochState {
            EpochChangeSync(u16),
            EpochChangeDone(u64),
            NextParamsSelected(u64),
        }
        impl EpochState {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn advance_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<
                crate::sui::vec_map::VecMap<
                    ObjectId,
                    crate::sui::balance::Balance<crate::wal::wal::WAL>,
                >,
            >,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("advance_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn apportionment<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<crate::sui::vec_map::VecMap<ObjectId, u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("apportionment").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn calculate_rewards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
            p2: Arg<u64>,
            p3: Arg<u32>,
            p4: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("calculate_rewards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                )
                .into()
        }
        pub fn can_withdraw_staked_wal_early<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("can_withdraw_staked_wal_early").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn check_governance_authorization<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("check_governance_authorization").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn collect_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
        ) -> Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("collect_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Ref<'a, crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn compute_next_committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("compute_next_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn create_pool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<String>,
            p2: Arg<String>,
            p3: Arg<crate::walrus::node_metadata::NodeMetadata>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Vec<u8>>,
            p6: Arg<Vec<u8>>,
            p7: Arg<u16>,
            p8: Arg<u64>,
            p9: Arg<u64>,
            p10: Arg<u64>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            let p8 = p8.resolve_arg(builder);
            let p9 = p9.resolve_arg(builder);
            let p10 = p10.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_pool").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into(), p8.into(), p9.into(), p10.into()
                    ],
                )
                .into()
        }
        pub fn destroy_empty_pool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty_pool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn dhondt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u64>>,
            p1: Arg<u16>,
            p2: Arg<Vec<u64>>,
        ) -> Arg<Vec<u16>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("dhondt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn epoch_sync_done<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u32>,
            p3: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch_sync_done").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn get_current_node_weight<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_current_node_weight").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn has_pool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("has_pool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn initiate_epoch_change<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::sui::clock::Clock>,
            p2: Arg<
                crate::sui::vec_map::VecMap<
                    ObjectId,
                    crate::sui::balance::Balance<crate::wal::wal::WAL>,
                >,
            >,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("initiate_epoch_change").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn is_quorum<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<u16>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_quorum").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_quorum_for_n_shards(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_quorum_for_n_shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max_shards_per_node(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max_shards_per_node").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn n_shards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
            p2: Arg<u16>,
            p3: Ref<'a, crate::sui::clock::Clock>,
        ) -> Arg<crate::walrus::staking_inner::StakingInnerV1> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn new_walrus_context<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<crate::walrus::walrus_context::WalrusContext> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_walrus_context").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn next_bls_committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Arg<crate::walrus::bls_aggregate::BlsCommittee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("next_bls_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn next_committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Ref<'a, Option<crate::walrus::committee::Committee>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("next_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn next_epoch_params<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Ref<'a, crate::walrus::epoch_parameters::EpochParams> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("next_epoch_params").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
        ) -> Arg<crate::walrus::node_metadata::NodeMetadata> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn previous_committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) -> Ref<'a, crate::walrus::committee::Committee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("previous_committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn quorum_above<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::priority_queue::PriorityQueue<u64>>,
            p1: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("quorum_above").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn quorum_below<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::sui::priority_queue::PriorityQueue<u64>>,
            p1: Arg<u16>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("quorum_below").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn request_withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("request_withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn select_committee_and_calculate_votes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("select_committee_and_calculate_votes")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn set_commission_receiver<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
            p3: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_commission_receiver").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_governance_authorized<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<ObjectId>,
            p2: Arg<crate::walrus::auth::Authenticated>,
            p3: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_governance_authorized").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_name<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_name").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_network_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_network_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_next_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u16>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_next_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_node_capacity_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_capacity_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<crate::walrus::node_metadata::NodeMetadata>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_storage_price_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_storage_price_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_write_price_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_write_price_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn stake_with_pool<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
            p2: Arg<ObjectId>,
        ) -> Arg<crate::walrus::staked_wal::StakedWal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("stake_with_pool").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn try_join_active_set<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_join_active_set").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn voting_end<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Ref<'a, crate::sui::clock::Clock>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("voting_end").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_inner::StakingInnerV1>,
            p1: Arg<crate::walrus::staked_wal::StakedWal>,
        ) -> Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod staking_pool {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "staking_pool";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct StakingPool {
            pub id: ObjectId,
            pub state: crate::walrus::staking_pool::PoolState,
            pub voting_params: crate::walrus::staking_pool::VotingParams,
            pub node_info: crate::walrus::storage_node::StorageNodeInfo,
            pub activation_epoch: u32,
            pub latest_epoch: u32,
            pub wal_balance: u64,
            pub num_shares: u64,
            pub pending_shares_withdraw: crate::walrus::pending_values::PendingValues,
            pub pre_active_withdrawals: crate::walrus::pending_values::PendingValues,
            pub pending_commission_rate: crate::walrus::pending_values::PendingValues,
            pub commission_rate: u16,
            pub exchange_rates: crate::sui::table::Table<
                u32,
                crate::walrus::pool_exchange_rate::PoolExchangeRate,
            >,
            pub pending_stake: crate::walrus::pending_values::PendingValues,
            pub rewards_pool: crate::sui::balance::Balance<crate::wal::wal::WAL>,
            pub commission: crate::sui::balance::Balance<crate::wal::wal::WAL>,
            pub commission_receiver: crate::walrus::auth::Authorized,
            pub governance_authorized: crate::walrus::auth::Authorized,
            pub extra_fields: crate::sui::bag::Bag,
        }
        impl StakingPool {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct VotingParams {
            pub storage_price: u64,
            pub write_price: u64,
            pub node_capacity: u64,
        }
        impl VotingParams {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub enum PoolState {
            Active,
            Withdrawing(u32),
            Withdrawn,
        }
        impl PoolState {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn activation_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("activation_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn advance_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>>,
            p2: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("advance_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn calculate_rewards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u64>,
            p2: Arg<u32>,
            p3: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("calculate_rewards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn collect_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::walrus::auth::Authenticated>,
        ) -> Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("collect_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn commission_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("commission_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn commission_rate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("commission_rate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn commission_receiver<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Ref<'a, crate::walrus::auth::Authorized> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("commission_receiver").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy_empty(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::staking_pool::StakingPool>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn exchange_rate_at_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u32>,
        ) -> Arg<crate::walrus::pool_exchange_rate::PoolExchangeRate> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("exchange_rate_at_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn governance_authorized<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Ref<'a, crate::walrus::auth::Authorized> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("governance_authorized").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_active<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_active").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_withdrawing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_withdrawing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
            p1: Arg<String>,
            p2: Arg<crate::walrus::node_metadata::NodeMetadata>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
            p5: Arg<Vec<u8>>,
            p6: Arg<u16>,
            p7: Arg<u64>,
            p8: Arg<u64>,
            p9: Arg<u64>,
            p10: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<crate::walrus::staking_pool::StakingPool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            let p8 = p8.resolve_arg(builder);
            let p9 = p9.resolve_arg(builder);
            let p10 = p10.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into(), p8.into(), p9.into(), p10.into()
                    ],
                )
                .into()
        }
        pub fn node_capacity<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_capacity").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn node_info<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Ref<'a, crate::walrus::storage_node::StorageNodeInfo> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_info").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn process_pending_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("process_pending_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn request_withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: MutRef<'a, crate::walrus::staked_wal::StakedWal>,
            p2: Arg<bool>,
            p3: Arg<bool>,
            p4: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("request_withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn rewards_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rewards_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn set_commission_receiver<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::walrus::auth::Authenticated>,
            p2: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_commission_receiver").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_governance_authorized<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::walrus::auth::Authenticated>,
            p2: Arg<crate::walrus::auth::Authorized>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_governance_authorized").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_name<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_name").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_network_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_network_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_next_commission<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u16>,
            p2: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_commission").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn set_next_node_capacity<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_node_capacity").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_next_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_next_storage_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_storage_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_next_write_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_write_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::walrus::node_metadata::NodeMetadata>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_withdrawing<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_withdrawing").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>>,
            p2: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<crate::walrus::staked_wal::StakedWal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn storage_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("storage_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn wal_balance<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("wal_balance").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn wal_balance_at_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<u32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("wal_balance_at_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn withdraw_stake<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::staking_pool::StakingPool>,
            p1: Arg<crate::walrus::staked_wal::StakedWal>,
            p2: Arg<bool>,
            p3: Arg<bool>,
            p4: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("withdraw_stake").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                )
                .into()
        }
        pub fn write_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::staking_pool::StakingPool>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("write_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod storage_accounting {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "storage_accounting";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct FutureAccounting {
            pub epoch: u32,
            pub used_capacity: u64,
            pub rewards_to_distribute: crate::sui::balance::Balance<
                crate::wal::wal::WAL,
            >,
        }
        impl FutureAccounting {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct FutureAccountingRingBuffer {
            pub current_index: u32,
            pub length: u32,
            pub ring_buffer: Vec<crate::walrus::storage_accounting::FutureAccounting>,
        }
        impl FutureAccountingRingBuffer {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn delete_empty_future_accounting(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::storage_accounting::FutureAccounting>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_empty_future_accounting").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_accounting::FutureAccounting>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn increase_used_capacity<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_accounting::FutureAccounting>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("increase_used_capacity").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max_epochs_ahead<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_accounting::FutureAccountingRingBuffer>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max_epochs_ahead").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new_future_accounting(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u64>,
            p2: Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>>,
        ) -> Arg<crate::walrus::storage_accounting::FutureAccounting> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_future_accounting").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn rewards_balance<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_accounting::FutureAccounting>,
        ) -> MutRef<'a, crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rewards_balance").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ring_lookup_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<
                'a,
                crate::walrus::storage_accounting::FutureAccountingRingBuffer,
            >,
            p1: Arg<u32>,
        ) -> MutRef<'a, crate::walrus::storage_accounting::FutureAccounting> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ring_lookup_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn ring_new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<crate::walrus::storage_accounting::FutureAccountingRingBuffer> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ring_new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ring_pop_expand<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_accounting::FutureAccountingRingBuffer>,
        ) -> Arg<crate::walrus::storage_accounting::FutureAccounting> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ring_pop_expand").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn unwrap_balance(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::storage_accounting::FutureAccounting>,
        ) -> Arg<crate::sui::balance::Balance<crate::wal::wal::WAL>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("unwrap_balance").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn used_capacity<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_accounting::FutureAccounting>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("used_capacity").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod storage_node {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "storage_node";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct StorageNodeCap {
            pub id: ObjectId,
            pub node_id: ObjectId,
            pub last_epoch_sync_done: u32,
            pub last_event_blob_attestation: Option<
                crate::walrus::event_blob::EventBlobAttestation,
            >,
            pub deny_list_root: move_types::U256,
            pub deny_list_sequence: u64,
            pub deny_list_size: u64,
        }
        impl StorageNodeCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct StorageNodeInfo {
            pub name: String,
            pub node_id: ObjectId,
            pub network_address: String,
            pub public_key: crate::sui::group_ops::Element<
                crate::sui::bls12381::UncompressedG1,
            >,
            pub next_epoch_public_key: Option<
                crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
            >,
            pub network_public_key: Vec<u8>,
            pub metadata: crate::walrus::extended_field::ExtendedField<
                crate::walrus::node_metadata::NodeMetadata,
            >,
        }
        impl StorageNodeInfo {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn deny_list_root<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_root").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn deny_list_sequence<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("deny_list_sequence").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::storage_node::StorageNodeInfo>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeInfo>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn last_epoch_sync_done<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("last_epoch_sync_done").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn last_event_blob_attestation<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) -> Arg<Option<crate::walrus::event_blob::EventBlobAttestation>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("last_event_blob_attestation").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeInfo>,
        ) -> Arg<crate::walrus::node_metadata::NodeMetadata> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
            p1: Arg<ObjectId>,
            p2: Arg<String>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
            p5: Arg<crate::walrus::node_metadata::NodeMetadata>,
        ) -> Arg<crate::walrus::storage_node::StorageNodeInfo> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into()
                    ],
                )
                .into()
        }
        pub fn new_cap<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<ObjectId>,
        ) -> Arg<crate::walrus::storage_node::StorageNodeCap> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new_cap").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn next_epoch_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeInfo>,
        ) -> Ref<
            'a,
            crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
        > {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("next_epoch_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn node_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("node_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_node::StorageNodeInfo>,
        ) -> Ref<
            'a,
            crate::sui::group_ops::Element<crate::sui::bls12381::UncompressedG1>,
        > {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn rotate_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("rotate_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn set_deny_list_properties<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p1: Arg<move_types::U256>,
            p2: Arg<u64>,
            p3: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_deny_list_properties").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn set_last_epoch_sync_done<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p1: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_last_epoch_sync_done").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_last_event_blob_attestation<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p1: Arg<crate::walrus::event_blob::EventBlobAttestation>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_last_event_blob_attestation").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_name<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_name").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_network_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_network_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_network_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_next_public_key<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_next_public_key").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn set_node_metadata<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_node::StorageNodeInfo>,
            p1: Arg<crate::walrus::node_metadata::NodeMetadata>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_node_metadata").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod storage_resource {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "storage_resource";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct Storage {
            pub id: ObjectId,
            pub start_epoch: u32,
            pub end_epoch: u32,
            pub storage_size: u64,
        }
        impl Storage {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn create_storage<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u32>,
            p2: Arg<u64>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_storage").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn destroy(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn end_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_resource::Storage>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("end_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extend_end_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_end_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn fuse<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fuse").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn fuse_amount<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fuse_amount").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn fuse_periods<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fuse_periods").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_resource::Storage>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn split_by_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<u32>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split_by_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn split_by_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::storage_resource::Storage>,
            p1: Arg<u64>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("split_by_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn start_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::storage_resource::Storage>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("start_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod system {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "system";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct System {
            pub id: ObjectId,
            pub version: u64,
            pub package_id: ObjectId,
            pub new_package_id: Option<ObjectId>,
        }
        impl System {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn add_subsidy<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
            p2: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_subsidy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn advance_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Arg<crate::walrus::bls_aggregate::BlsCommittee>,
            p2: Ref<'a, crate::walrus::epoch_parameters::EpochParams>,
        ) -> Arg<
            crate::sui::vec_map::VecMap<
                ObjectId,
                crate::sui::balance::Balance<crate::wal::wal::WAL>,
            >,
        > {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("advance_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn certify_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn certify_event_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<move_types::U256>,
            p3: Arg<move_types::U256>,
            p4: Arg<u64>,
            p5: Arg<u8>,
            p6: Arg<u64>,
            p7: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_event_blob").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into()
                    ],
                );
        }
        pub fn create_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn delete_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
            p1: Arg<crate::walrus::blob::Blob>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn delete_deny_listed_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_deny_listed_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extend_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<u32>,
            p3: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn extend_blob_with_resource<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_blob_with_resource").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn inner<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn inner_mut<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
        ) -> MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("inner_mut").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn invalidate_blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("invalidate_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn migrate<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("migrate").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn n_shards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn package_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<ObjectId> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("package_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn register_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
            p2: Arg<move_types::U256>,
            p3: Arg<move_types::U256>,
            p4: Arg<u64>,
            p5: Arg<u8>,
            p6: Arg<bool>,
            p7: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) -> Arg<crate::walrus::blob::Blob> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("register_blob").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into()
                    ],
                )
                .into()
        }
        pub fn register_deny_list_update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<move_types::U256>,
            p3: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("register_deny_list_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn reserve_space<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Arg<u64>,
            p2: Arg<u32>,
            p3: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reserve_space").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn set_new_package_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: Arg<ObjectId>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set_new_package_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn total_capacity_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("total_capacity_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn update_deny_list<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system::System>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_deny_list").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn used_capacity_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("used_capacity_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn version<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system::System>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("version").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod system_state_inner {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "system_state_inner";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct SystemStateInnerV1 {
            pub committee: crate::walrus::bls_aggregate::BlsCommittee,
            pub total_capacity_size: u64,
            pub used_capacity_size: u64,
            pub storage_price_per_unit_size: u64,
            pub write_price_per_unit_size: u64,
            pub future_accounting: crate::walrus::storage_accounting::FutureAccountingRingBuffer,
            pub event_blob_certification_state: crate::walrus::event_blob::EventBlobCertificationState,
            pub deny_list_sizes: crate::walrus::extended_field::ExtendedField<
                crate::sui::vec_map::VecMap<ObjectId, u64>,
            >,
        }
        impl SystemStateInnerV1 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn add_subsidy<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<crate::sui::coin::Coin<crate::wal::wal::WAL>>,
            p2: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_subsidy").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn advance_epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<crate::walrus::bls_aggregate::BlsCommittee>,
            p2: Ref<'a, crate::walrus::epoch_parameters::EpochParams>,
        ) -> Arg<
            crate::sui::vec_map::VecMap<
                ObjectId,
                crate::sui::balance::Balance<crate::wal::wal::WAL>,
            >,
        > {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("advance_epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn certify_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn certify_event_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<move_types::U256>,
            p3: Arg<move_types::U256>,
            p4: Arg<u64>,
            p5: Arg<u8>,
            p6: Arg<u64>,
            p7: Arg<u32>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("certify_event_blob").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into()
                    ],
                );
        }
        pub fn committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
        ) -> Ref<'a, crate::walrus::bls_aggregate::BlsCommittee> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn create_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<crate::walrus::system_state_inner::SystemStateInnerV1> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn delete_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<crate::walrus::blob::Blob>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn delete_deny_listed_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("delete_deny_listed_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn extend_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<u32>,
            p3: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_blob").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn extend_blob_with_resource<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: MutRef<'a, crate::walrus::blob::Blob>,
            p2: Arg<crate::walrus::storage_resource::Storage>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extend_blob_with_resource").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn invalidate_blob_id<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<Vec<u8>>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("invalidate_blob_id").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn n_shards<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("n_shards").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn process_storage_payments<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<u64>,
            p2: Arg<u32>,
            p3: Arg<u32>,
            p4: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("process_storage_payments").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn register_blob<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<crate::walrus::storage_resource::Storage>,
            p2: Arg<move_types::U256>,
            p3: Arg<move_types::U256>,
            p4: Arg<u64>,
            p5: Arg<u8>,
            p6: Arg<bool>,
            p7: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) -> Arg<crate::walrus::blob::Blob> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            let p5 = p5.resolve_arg(builder);
            let p6 = p6.resolve_arg(builder);
            let p7 = p7.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("register_blob").unwrap(),
                        vec![],
                    ),
                    vec![
                        p0.into(), p1.into(), p2.into(), p3.into(), p4.into(), p5.into(),
                        p6.into(), p7.into()
                    ],
                )
                .into()
        }
        pub fn register_deny_list_update<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Ref<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<move_types::U256>,
            p3: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("register_deny_list_update").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn reserve_space<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<u64>,
            p2: Arg<u32>,
            p3: MutRef<'a, crate::sui::coin::Coin<crate::wal::wal::WAL>>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reserve_space").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn reserve_space_without_payment<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<u64>,
            p2: Arg<u32>,
            p3: Arg<bool>,
        ) -> Arg<crate::walrus::storage_resource::Storage> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reserve_space_without_payment").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                )
                .into()
        }
        pub fn total_capacity_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("total_capacity_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn update_deny_list<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: MutRef<'a, crate::walrus::storage_node::StorageNodeCap>,
            p2: Arg<Vec<u8>>,
            p3: Arg<Vec<u8>>,
            p4: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("update_deny_list").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
        pub fn used_capacity_size<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("used_capacity_size").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn write_price<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::system_state_inner::SystemStateInnerV1>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("write_price").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod upgrade {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "upgrade";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct EmergencyUpgradeCap {
            pub id: ObjectId,
            pub upgrade_manager_id: ObjectId,
        }
        impl EmergencyUpgradeCap {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct PackageDigest {
            pub pos0: Vec<u8>,
        }
        impl PackageDigest {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct, Key)]
        pub struct UpgradeManager {
            pub id: ObjectId,
            pub cap: crate::sui::package::UpgradeCap,
            pub upgrade_proposals: crate::sui::table::Table<
                crate::walrus::upgrade::PackageDigest,
                crate::walrus::upgrade::UpgradeProposal,
            >,
        }
        impl UpgradeManager {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UpgradeProposal {
            pub epoch: u32,
            pub digest: crate::walrus::upgrade::PackageDigest,
            pub version: u64,
            pub voting_weight: u16,
            pub voters: crate::sui::vec_set::VecSet<ObjectId>,
        }
        impl UpgradeProposal {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn add_vote<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeProposal>,
            p1: Arg<ObjectId>,
            p2: Arg<u16>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add_vote").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn authorize_emergency_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeManager>,
            p1: Ref<'a, crate::walrus::upgrade::EmergencyUpgradeCap>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::package::UpgradeTicket> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authorize_emergency_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn authorize_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeManager>,
            p1: Ref<'a, crate::walrus::staking::Staking>,
            p2: Arg<Vec<u8>>,
        ) -> Arg<crate::sui::package::UpgradeTicket> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("authorize_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn burn_emergency_upgrade_cap(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::walrus::upgrade::EmergencyUpgradeCap>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("burn_emergency_upgrade_cap").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn cleanup_upgrade_proposals<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeManager>,
            p1: Ref<'a, crate::walrus::staking::Staking>,
            p2: Arg<Vec<Vec<u8>>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("cleanup_upgrade_proposals").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn commit_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeManager>,
            p1: MutRef<'a, crate::walrus::staking::Staking>,
            p2: MutRef<'a, crate::walrus::system::System>,
            p3: Arg<crate::sui::package::UpgradeReceipt>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("commit_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into()],
                );
        }
        pub fn fresh_proposal(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<crate::walrus::upgrade::PackageDigest>,
            p2: Arg<u64>,
        ) -> Arg<crate::walrus::upgrade::UpgradeProposal> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fresh_proposal").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn new<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::sui::package::UpgradeCap>,
        ) -> Arg<crate::walrus::upgrade::EmergencyUpgradeCap> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn vote_for_upgrade<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::walrus::upgrade::UpgradeManager>,
            p1: Ref<'a, crate::walrus::staking::Staking>,
            p2: Arg<crate::walrus::auth::Authenticated>,
            p3: Arg<ObjectId>,
            p4: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            let p3 = p3.resolve_arg(builder);
            let p4 = p4.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("vote_for_upgrade").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into(), p3.into(), p4.into()],
                );
        }
    }
    pub mod walrus_context {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
            197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
            179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
        ]);
        pub const MODULE_NAME: &str = "walrus_context";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct WalrusContext {
            pub epoch: u32,
            pub committee_selected: bool,
            pub committee: crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>,
        }
        impl WalrusContext {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                216u8, 71u8, 4u8, 193u8, 127u8, 200u8, 112u8, 184u8, 118u8, 72u8, 50u8,
                197u8, 53u8, 170u8, 107u8, 17u8, 242u8, 26u8, 149u8, 205u8, 111u8, 91u8,
                179u8, 138u8, 155u8, 7u8, 210u8, 207u8, 66u8, 34u8, 12u8, 102u8,
            ]);
        }
        pub fn committee<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Ref<'a, crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("committee").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn committee_selected<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("committee_selected").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn epoch<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::walrus::walrus_context::WalrusContext>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("epoch").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<bool>,
            p2: Arg<crate::sui::vec_map::VecMap<ObjectId, Vec<u16>>>,
        ) -> Arg<crate::walrus::walrus_context::WalrusContext> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
    }
}
