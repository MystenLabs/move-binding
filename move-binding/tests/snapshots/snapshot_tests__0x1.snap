---
source: move-binding/tests/snapshot_tests.rs
expression: pretty
---
pub mod move_lib {
    pub const PACKAGE_VERSION: u64 = 16u64;
    pub mod address {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "address";
        pub fn length(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<u64> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![],
                )
                .into()
        }
    }
    pub mod ascii {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "ascii";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Char {
            pub byte: u8,
        }
        impl Char {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct String {
            pub bytes: Vec<u8>,
        }
        impl String {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn all_characters_printable<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("all_characters_printable").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn append<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("append").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn as_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("as_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn byte(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::ascii::Char>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("byte").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn char(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<crate::move_lib::ascii::Char> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("char").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn char_to_lowercase(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("char_to_lowercase").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn char_to_uppercase(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("char_to_uppercase").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn index_of<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Ref<'a, String>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("index_of").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<u64>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn into_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_printable_char(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_printable_char").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_valid_char(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_valid_char").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pop_char<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
        ) -> Arg<crate::move_lib::ascii::Char> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_char").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn push_char<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<crate::move_lib::ascii::Char>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("push_char").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn substring<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("substring").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn to_lowercase<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_lowercase").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_uppercase<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_uppercase").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Option<String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod bcs {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "bcs";
        pub fn to_bytes<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_bytes").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod bit_vector {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "bit_vector";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct BitVector {
            pub length: u64,
            pub bit_field: Vec<bool>,
        }
        impl BitVector {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn is_index_set<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::move_lib::bit_vector::BitVector>,
            p1: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_index_set").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::move_lib::bit_vector::BitVector>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn longest_set_sequence_starting_at<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, crate::move_lib::bit_vector::BitVector>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("longest_set_sequence_starting_at")
                            .unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn new(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::move_lib::bit_vector::BitVector> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("new").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn set<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::move_lib::bit_vector::BitVector>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("set").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn shift_left<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::move_lib::bit_vector::BitVector>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("shift_left").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn unset<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, crate::move_lib::bit_vector::BitVector>,
            p1: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("unset").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
    }
    pub mod debug {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "debug";
        pub fn print<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("print").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn print_stack_trace(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("print_stack_trace").unwrap(),
                        vec![],
                    ),
                    vec![],
                );
        }
    }
    pub mod fixed_point32 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "fixed_point32";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct FixedPoint32 {
            pub value: u64,
        }
        impl FixedPoint32 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn create_from_rational(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<crate::move_lib::fixed_point32::FixedPoint32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_from_rational").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn create_from_raw_value(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::move_lib::fixed_point32::FixedPoint32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("create_from_raw_value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn divide_u64(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<crate::move_lib::fixed_point32::FixedPoint32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn get_raw_value(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::fixed_point32::FixedPoint32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_raw_value").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_zero(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::fixed_point32::FixedPoint32>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_zero").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn multiply_u64(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<crate::move_lib::fixed_point32::FixedPoint32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("multiply_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
    pub mod hash {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "hash";
        pub fn sha2_256(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sha2_256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn sha3_256(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sha3_256").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod option {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "option";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct Option<T0> {
            pub vec: Vec<T0>,
        }
        impl<T0> Option<T0> {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn borrow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Option<T0>>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn borrow_with_default<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
            p1: Ref<'a, T0>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_with_default").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_none<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Option<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_none").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn destroy_some<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Option<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_some").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn destroy_with_default<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Option<T0>>,
            p1: Arg<T0>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_with_default").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn extract<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Option<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("extract").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn fill<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Option<T0>>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("fill").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn get_with_default<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
            p1: Arg<T0>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_with_default").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn is_none<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_none").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_some<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Option<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_some").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn none<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Option<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("none").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn some<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("some").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn swap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Option<T0>>,
            p1: Arg<T0>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn swap_or_fill<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Option<T0>>,
            p1: Arg<T0>,
        ) -> Arg<Option<T0>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap_or_fill").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn to_vec<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Option<T0>>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_vec").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod string {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "string";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct String {
            pub bytes: Vec<u8>,
        }
        impl String {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn append<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("append").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn append_utf8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<Vec<u8>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("append_utf8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn as_bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("as_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn bytes<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Ref<'a, Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_ascii(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_ascii").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn index_of<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Ref<'a, String>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("index_of").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, String>,
            p1: Arg<u64>,
            p2: Arg<String>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn internal_check_utf8<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_check_utf8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn internal_index_of<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Ref<'a, Vec<u8>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_index_of").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_is_char_boundary<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Arg<u64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_is_char_boundary").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn internal_sub_string<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<u8>>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("internal_sub_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn into_bytes(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<Vec<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_bytes").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_empty<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn sub_string<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sub_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn substring<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("substring").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                )
                .into()
        }
        pub fn to_ascii(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_ascii").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_utf8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<Option<String>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_utf8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn utf8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<u8>>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("utf8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod type_name {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "type_name";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct TypeName {
            pub name: String,
        }
        impl TypeName {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn borrow_string<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Ref<'a, String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn get_address<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_address").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_module<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_module").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn get_with_original_ids<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<String> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("get_with_original_ids").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn into_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<String>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("into_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn is_primitive<'a>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, String>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_primitive").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u128 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u128";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u8>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u16(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<Option<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u32(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<Option<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u64(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u16 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u16";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
            p1: Arg<u8>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<u16> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u16>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u256 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u256";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<move_types::U256>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<move_types::U256>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<move_types::U256>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<move_types::U256>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
            p1: Arg<u8>,
        ) -> Arg<move_types::U256> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u128(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Option<u128>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u128").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u16(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Option<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u32(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Option<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u64(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Option<u64>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u64").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<move_types::U256>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u32 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u32";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
            p1: Arg<u8>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u16(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<Option<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u64 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u64";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u8>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u16(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<Option<u16>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u16").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u32(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<Option<u32>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u32").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn try_as_u8(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<Option<u8>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("try_as_u8").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod u8 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "u8";
        pub fn bitwise_not(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("bitwise_not").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn diff(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("diff").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn divide_and_round_up(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("divide_and_round_up").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn max(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("max").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn min(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("min").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn pow(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
            p1: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pow").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sqrt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<u8> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sqrt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_string(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u8>,
        ) -> Arg<String> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_string").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod uq32_32 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "uq32_32";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UQ32_32 {
            pub pos0: u64,
        }
        impl UQ32_32 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn add(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn div(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_int(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u32>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_int").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_quotient(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<u64>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_quotient").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_raw(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_raw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ge(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ge").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn int_div(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("int_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn int_mul(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("int_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn le(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("le").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn lt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("lt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn mul(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sub(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
            p1: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<crate::move_lib::uq32_32::UQ32_32> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn to_int(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<u32> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_int").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_raw(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq32_32::UQ32_32>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_raw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod uq64_64 {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "uq64_64";
        #[derive(serde::Deserialize, serde::Serialize, Debug, MoveStruct)]
        pub struct UQ64_64 {
            pub pos0: u128,
        }
        impl UQ64_64 {
            pub const TYPE_ORIGIN_ID: Address = Address::new([
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
                0u8, 0u8, 0u8, 1u8,
            ]);
        }
        pub fn add(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("add").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn div(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_int(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u64>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_int").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn from_quotient(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<u128>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_quotient").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn from_raw(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("from_raw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn ge(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("ge").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn gt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("gt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn int_div(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("int_div").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn int_mul(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<u128>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("int_mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn le(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("le").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn lt(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("lt").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn mul(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("mul").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn sub(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
            p1: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<crate::move_lib::uq64_64::UQ64_64> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("sub").unwrap(),
                        vec![],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn to_int(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_int").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn to_raw(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<crate::move_lib::uq64_64::UQ64_64>,
        ) -> Arg<u128> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("to_raw").unwrap(),
                        vec![],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
    }
    pub mod vector {
        use std::str::FromStr;
        use move_binding_derive::{MoveStruct, Key};
        use move_types::{MoveType, Address, Identifier, ObjectId};
        use move_types::functions::{Arg, Ref, MutRef};
        pub const PACKAGE_ID: Address = Address::new([
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,
            0u8, 1u8,
        ]);
        pub const MODULE_NAME: &str = "vector";
        pub fn append<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<Vec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("append").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn borrow<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<T0>>,
            p1: Arg<u64>,
        ) -> Ref<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn borrow_mut<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<u64>,
        ) -> MutRef<'a, T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("borrow_mut").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn contains<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("contains").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn destroy_empty<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("destroy_empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn empty<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
        ) -> Arg<Vec<T0>> {
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![],
                )
                .into()
        }
        pub fn flatten<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<Vec<Vec<T0>>>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("flatten").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn index_of<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<T0>>,
            p1: Ref<'a, T0>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("index_of").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn insert<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<T0>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("insert").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn is_empty<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<T0>>,
        ) -> Arg<bool> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("is_empty").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn length<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Ref<'a, Vec<T0>>,
        ) -> Arg<u64> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("length").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn pop_back<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("pop_back").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn push_back<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<T0>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("push_back").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                );
        }
        pub fn remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<u64>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
        pub fn reverse<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
        ) {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("reverse").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                );
        }
        pub fn singleton<T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: Arg<T0>,
        ) -> Arg<Vec<T0>> {
            let p0 = p0.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("singleton").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into()],
                )
                .into()
        }
        pub fn swap<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<u64>,
            p2: Arg<u64>,
        ) {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            let p2 = p2.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into(), p2.into()],
                );
        }
        pub fn swap_remove<'a, T0: MoveType>(
            builder: &mut sui_transaction_builder::TransactionBuilder,
            p0: MutRef<'a, Vec<T0>>,
            p1: Arg<u64>,
        ) -> Arg<T0> {
            let p0 = p0.resolve_arg(builder);
            let p1 = p1.resolve_arg(builder);
            builder
                .move_call(
                    sui_transaction_builder::Function::new(
                        PACKAGE_ID,
                        Identifier::from_str(MODULE_NAME).unwrap(),
                        Identifier::from_str("swap_remove").unwrap(),
                        vec![T0::type_()],
                    ),
                    vec![p0.into(), p1.into()],
                )
                .into()
        }
    }
}
